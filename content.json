{"posts":[{"title":"2022 年回顧","text":"今年無論是個人成長或是身體健康，可以說是滿滿收穫的一年 趁著時間要來到 2023 年之前，留下個紀錄，並且許願明年會更好。 健康9 月的時候確診了，在家隔離的休養身體的期間，因為過著與世隔絕的生活，讓心靈有了淨空的感覺。發覺這樣的體驗是很難得的，所以記錄下來。 也是下半年開始，打了幾次的週日排球，下班後偶而去跑步，每次運動完都很快樂、很舒暢。有太多不開心的事情，透過運動抒發也是很棒的方法。 認真吃保健食品，目前主要吃葉黃素果凍顧眼睛、睿智膏顧睡眠；有時候覺得疲勞的時候，會從超商買養氣人蔘來喝。不過也是年底才開始吃，有沒有效果還要過一陣子看看。 閱讀變成我生活中不可或缺的事情今年可以說是這輩子讀最多書的一年。 年初的時候開始使用 kobo，原本只是想著今年只要能看到兩三本書就很滿意了，後來參加了公司內部導讀會跟內部主管的修煉課程之後，幾乎每個月都有一兩本書要看。 原本只是想依賴團體的力量來看書，後來自己也開始找有興趣的書來看，漸漸的我的生活起了變化，我會在通勤的時間用手機看 kobo，週末也會在家裡看書，連公司的桌上都放了幾本工具書，隨時可以翻閱。 適合自己的工作模式今年第一次跑 Scrum 就跑了 9 個月，做了許多有趣的題目，因為是團隊自己決定要做什麼專案，都有越做越有默契的感覺，就好像一支球隊一樣。 透過 Scrum 的工作方法，我體驗到了目標的認同感、以爲使用者帶來價值作為原則以及溝通效率的美好，也確定了我在敏捷的工作模式下比較能發揮自己的能力。 工程師職涯的種子發芽了下半年開始感覺到自己的成長，就好像一顆種子用力的發芽一樣。 今年有培訓新人的機會，讓我發現自己的「傳承能力」，因為我過去有 PM 的經驗，讓我在安排新人的學習目標很有幫助。我認為比起技術，教他們了解怎麼跟團隊協作比較重要。 參與招募也讓我得到了啟發：「面試不是要把人考倒，最終還是要看彼此合不合適。」也因此，未來自己求職的時候，應該也會用這種心態來看待求職結果吧。 技術方面： 更精進 JS 跟 Vue，還做了大型的重構。 把 Webpack 學起來了，並且實際優化了編譯時間、檔案大小 對 Git 的掌握度到達了「很有自信的地步」，不怕玩壞，只怕沒紀錄 接觸到更多的技術議題跟知識：數據追蹤, SEO, E2E testing, Docker, DevOps… 明年展望希望未來一年能做到的事情： 學會 React 生態系、Unit Test、Docker 保持閱讀習慣 增加運動量 用寫作分享自己的事","link":"/blog/2022/12/30/2022-retrospective/"},{"title":"[HTML]把header做成template","text":"最近在做純靜態的網站，沒有引入Vue或其他的框架，每一次新的頁面的&lt;header&gt;都從第一頁複製，在新的頁面貼上，一旦內容要做變更，我就必須再次複製貼上… 覺得這樣的方式實在太蠢了！ 後來想到可以用JS的方式放入HTML，只要在不同的頁面抓到標籤是id=header就好了。(同理，footer也可以這樣做) index.html12345678&lt;body&gt; &lt;header id=&quot;header&quot;&gt;&lt;/header&gt; &lt;div&gt; 你好這是首頁 &lt;/div&gt; &lt;footer id=&quot;footer&quot;&gt;&lt;/footer&gt; &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; user.html12345678&lt;body&gt; &lt;header id=&quot;header&quot;&gt;&lt;/header&gt; &lt;div&gt; 你好這是使用者頁 &lt;/div&gt; &lt;footer id=&quot;footer&quot;&gt;&lt;/footer&gt; &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; script.js12345678910111213/* header的樣板 */let header = `&lt;div class=&quot;nav&quot;&gt; &lt;div class=&quot;nav-item&quot;&gt; &lt;a href=&quot;index.html&quot;&gt;首頁&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;nav-item&quot;&gt; &lt;a href=&quot;index.html&quot;&gt;使用者頁&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;`document.getElementById('header').innerHTML = header// 同理，footer也可以這樣做 參考：模板字符串","link":"/blog/2020/11/02/HTML-%E6%8A%8Aheader%E5%81%9A%E6%88%90template/"},{"title":"Vue元件溝通-子傳父($emit)","text":"常常忘記子傳父($emit)的寫法，這裡筆記一下子件的事件被觸發的時候要做事把事件綁在template上@click-child 123456789101112131415161718192021222324252627/* 子元件 */&lt;div id=&quot;child&quot;&gt; &lt;span&gt;子元件&lt;/span&gt; &lt;button @click=&quot;clickButton&quot;&gt;Click!&lt;/button&gt;&lt;/div&gt;...methods: { clickButton(){ this.$emit('click-child') }}/* 父元件 */&lt;div id=&quot;parent&quot;&gt; &lt;span&gt;父元件&lt;/span&gt; &lt;child @click-child=&quot;sayHi&quot;&gt;&lt;/child&gt;&lt;/div&gt;...methods: { sayHi(){ alert('Hi~~') }}... $emit用 kebab-case 命名法比較好，原因是vue會把大小寫全部轉成小寫，可能會造成變數名稱有問題","link":"/blog/2020/10/13/Vue%E5%85%83%E4%BB%B6%E6%BA%9D%E9%80%9A-%E5%AD%90%E5%82%B3%E7%88%B6-emit/"},{"title":"我是如何轉職前端工程師(泰山前端網頁開發技術)","text":"之前的文章有提到，為什麼我不繼續做聖騎士PM。 從上份工作離職後、參加職訓前，也有投工程師的相關工作，但實在沒有技術力，面試都被洗臉，也不知道從何開始精進。 後來經由三重就業服務中心推介，報名泰山職業訓練場的前端網頁開發技術(青年專班)，上了半年的課順利拿到結訓證書。 報名職訓先是申請報名，然後會經由筆試/口試來篩選人，有錄取的話會公告在網站上。 筆試是網頁設計丙級的學科跟一些邏輯題目，可以Google搜尋「網頁設計丙級學科」，也有該課程歷屆考古題可以參考。 口試的話由授課教師跟你面談，這個部份我被問了「有沒有網路的基礎跟電腦的基礎」，然後就結束等錄取公告了。 我是怎麼度過這半年的職訓每天八點十分上課(需打卡)，下課回家後花固定時間寫作業，才有餘力過自己生活，也不能太晚睡，因為隔天還要上課。 早點到教室可以跟同學一起吃早餐交流，可以把似懂非懂的問題去跟同學討論，多半時候大家會一起變強。 進入課程後，會輔導考網頁設計丙級證照，需要自費繳交報名費。如果有好好跟著上課、並且考前都有刷丙級學科題目的話就能順利考過了。 課堂會出作業，如果做得好的話可以整理成自己的作品集 上課有問題都可以問老師，老師都很熱心可以幫忙，我自己也是覺得不要浪費在職訓的時間，盡量問到飽。 上課如果可以跟著做筆記很好，如果做筆記就跟不上的話還是專心聽課，做筆記只是輔助。這部分在結訓後幫我很多，上課的東西不可能每個都記住，用到的時候就還能回頭查，像是現在工作後還會用到的筆記：HTML&amp;CSS 在心態上，我盡量提醒自己「自己懂了沒，有沒有辦法應用學到的東西」，我用了半年的時間專注在成長上，可以從這裡看我的成果。 結訓後的我如何了結訓後，除了投履歷、面試之外，每天就是不斷的去改進自己的專題、履歷，花了一個月的時間成功找到現在的工作，成為準時上下班的前端工程師。 如果你也想轉職網頁工程師，不妨參考泰山職訓網頁設計，你可以獲得更多課程資訊。","link":"/blog/2020/12/30/change-careers/"},{"title":"從觀望 Claude Code 到一頭栽進去 - EP1｜第一次就爆 token？","text":"📌 本文為系列文「從觀望 Claude Code 到一頭栽進去」的第一篇。系列將分享我從觀望到愛不釋手的 Claude Code 使用心得，包括省 token、優化流程、寫 MR、產出技術文件與工具比較。👉 完整系列文章列表請點這裡 原本買了保哥的課程：AI 程式設計代理人開發全攻略：從入門到實戰，跟完課程的 Claude Code 直播後，我其實還是有點猶豫要不要再多花一筆錢訂閱 Claude Pro。不過觀察到身邊的免費仔們紛紛開始課金，我就想：「嗯，好吧，那我也刷看看一個月 20 鎂的訂閱費。」 結果第一次用 Claude Code，我 1.5 小時就把 token 燒光，真的太快太猛了。 後來回去翻保哥課程的 Discord 和 Line 群的討論，才懂了要避免在同一個 Session 裡做太多不相關的事，不然上下文會越疊越厚，不只 token 爆掉，結果也會不太好。因為這樣我養成事情做完就/clear 的習慣。 但實際開發還是會遇到一些使用上的小障礙。有時跟還沒講完需求，Claude Code 就會直接生成 Todo 開始改 Code，這時候只能趕快用 ESC 打斷他，再跟他補充說明。 後來回看直播，才發現保哥其實有教過可以用 Shift + Tab 切 Plan Mode 先討論，再搭配以前常用 Github Copilot 時的開發技巧：先確認對方有沒有理解我的需求，確定 OK 才開始寫程式，透過這樣的方式就可以大幅提升 Claude Code 的準確率跟產出品質了。 用了幾天後我發現，這個錢真的花得很值得。我不只省下了時間，同時也從 Claude Code 的來回討論中學到很多東西。跟半年前用 Github Copilot 的開發體驗比起來，爽度又更上一層樓了。 我從「觀望 Claude Code」變成「沒有 Claude Code 就不太想寫程式」了。 在寫這篇文章的時候，覺得還有很多使用 Claude Code 的方式可以分享，預計把這篇文章當作系列文的第一篇，下次會想分享我是怎麼用 Claude Code 優化我的開發流程。 推薦課程｜AI 程式設計代理人開發全攻略：從入門到實戰保哥把 Claude Code、OpenAI Codex Cli、Gemini CLI 的應用都講得很清楚，像這篇提到的 /clear、切換 Plan Mode、用 ESC 打斷 Claude Code，在直播裡都有實際展示用法。👉 如果你有興趣可以透過 這個推薦連結 註冊課程，還可以延長一個月的觀看時間。","link":"/blog/2025/08/02/claude-code-first-use/"},{"title":"JavaScript 實作點擊按鈕複製文字功能","text":"讓使用者可以「點擊按鈕後複製文字」的功能，經常作為分享給好友、優惠碼等活動頁需求上。 本文主要以 Clipboard API 來實現，但IE 並不支援這個 API，另外也需要針對 iOS 進行特別處理。 Clipboard API 介紹複製文字會用寫入剪貼簿的 api，寫法如下: 1navigator.clipboard.writeText(newClipText) 這個函式會回傳一個 promise，可以用.then跟.catch來定義複製成功及複製失敗要做的事情。 IE 要怎麼辦?因為 IE 並不支援navigator.clipboard，可以用另外一個寫法來實現: 1window.clipboardData.setData(&quot;Text&quot;, newClipText); 雖然這個方法全部的瀏覽器都有能使用，但由於它是實驗中的 API，未來有可能會修訂，建議只用來處理 IE。 針對 iOS 進行特別處理iOS 上的瀏覽器不能直接操作剪貼簿，但如果： iOS 版本 &gt;=10 可以複製&lt;input&gt;、&lt;textarea&gt;元素的文字 元素內容可以編輯，並且元素沒有 readonly 屬性 必須在選取的狀態下才能複製 iOS 版本 &lt;10 沒辦法透過 js 來作到操作剪貼簿的功能，只能讓使用者用手勢來達成「複製文字」的功能。 詳細可參考這個討論串 範例程式碼完整的程式碼如下： 12&lt;input id=&quot;copyText&quot; type=&quot;text&quot; value=&quot;https://www.google.com/&quot;&gt;&lt;button onclick=&quot;copyHandler()&quot;&gt;點擊複製&lt;/button&gt; 1234567891011121314151617181920function copyHandler() { let shareUrlElement = document.getElementById(&quot;copyText&quot;); shareUrlElement.select(); shareUrlElement.setSelectionRange(0, 99999); let copyUrl = shareUrlElement.value; if (navigator.clipboard) { navigator.clipboard .writeText(copyUrl) .then((res) =&gt; { console.log(&quot;複製連結成功&quot;); }) .catch((rej) =&gt; { console.log(&quot;無法複製連結&quot;); }); } else { // for IE window.clipboardData.setData(&quot;Text&quot;, copyUrl); }} 參考資料How To Copy to Clipboard如何用 Javascript 複製文字﹍跨瀏覽器相容 iOS＠WFU BLOGCopy to clipboard using Javascript in iOS - Stack OverflowClipboard API - Web API 接口参考 | MDNClipboardEvent.clipboardData - Web API 接口参考 | MDN","link":"/blog/2022/03/02/copy-to-clipboard-using-javascript/"},{"title":"CSS Flexbox 屬性及用法","text":"Flexbox 是什麼？早期用 Box model 排版的時候，要用很多種方式來避免畫面跑版，但隨著時代進步，不同的裝置有不同的解析度，若每個裝置都要重新設計版面也太麻煩了！於是 Flexbox 就誕生啦！ Flexbox 解決了早期的排版問題，能夠隨著不同裝置來變化排版，可以自適應不同裝置的長寬稱為響應式布局（RWD）。 網路上有很多解釋 Flexbox 的文章，這裡主要說明 Flexbox 相關的屬性及用法。 開始使用設定display:flex;的元素是flex container，其子元素為flex item。 12345678910111213141516&lt;style&gt;.container{ /* parent set display:flex; */ display:flex;}&lt;/style&gt;&lt;body&gt; &lt;!-- parent is flex container --&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- chird is flex item --&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 屬性介紹下面屬性如果是預設值，會帶有⚙齒輪符號 flex container 的相關屬性設定在display:flex;同一個元素內的屬性 flex-direction 方向在畫面上要橫的還是直的 row⚙ 橫的，由左到右的row-reverse 橫的，由右到左的column 直的，由上到下的colume-reverse 直的，由下到上的 flex-wrap 換行全部item的寬度如果超過 container 的寬度，要不要換行 nowrap⚙ 不換行wrap 要換行。當 flex container 的寬度沒辦法容納所有 flex item，就把 flex item 換行 justify-content 水平對齊決定 item 之間的水平對齊方式 flex-start⚙ 齊頭flex-end 齊尾center 置中space-between 頭尾對齊，item 均分剩餘寬度space-around 頭尾分一個寬度，item 均分剩餘寬度space-evenly item均分剩餘寬度 align-items 垂直對齊決定 item 之間的垂直對齊方式 normal⚙ 基本上跟stretch一樣flex-start 齊頭flex-end 齊尾center 置中stretch 如果 item 沒有設定 height，就把item 拉伸到跟容器一樣高 flex item 的相關屬性設定在子元素的屬性 flex-grow 增長係數有剩餘空間的時候怎麼分配 0⚙ 不影響 width1 flex item width 占用1倍的剩餘空間，數字越大佔越多 flex-grow 怎麼分配剩餘空間 flex-shrink 收縮係數空間不夠的時候怎麼分配 0 flex item width 不要收縮，會直接爆出去1⚙ flex item width 有超出空間，就縮至超出空間的1倍。數字越大，收縮的比例越高 flex-shrink 怎麼收縮不夠的空間 flex-basis 基本寬度跟 width 很像，但如果有設定 flex-basis 的話，優先度會高於 width auto⚙ 內容決定寬度150px width 設為 150px。要注意的是，如果flex-direction: column;的時候，flex-basis就不是 width 而是 hight 。 設定 flex item 的寬 flex 縮寫屬性1234567/* 順序 grow shrink basis */flex: 0 1 150px;/* flex:0 1 150px; 等於下列 */flex-grow:0;flex-shrink:1;flex-basis:150px; Flexbox 怎麼設定長寬設定 flex item 的寬 沒有設定 width 會怎樣？內容會決定寬度。 設定了 width 會怎樣？width 決定寬度最大值width 會是 flex item 的最大寬度，也就是說寬度可以小於設定的 width ，但不會大於 width但如果想要固定 width 的話，可以用flex-wrap:wrap;來固定 設定 flex-grow 會怎樣?會依照 flex-grow 去分配 flex item 應該佔多少比例的寬，來填滿剩餘空間。如果有做 flex-basis 的設定，就等於是做寬度的最小值 設定 flex item 的高 沒有設定 height 會怎樣?內容會決定高度。 設定了 height 會怎樣?height 決定固定的高度。 結論在使用 flex 做排版的時候： flex container要設定display:flex;跟flex-wrap:wrap; flex item寬的設定 要設定 width ，或是設定 flex-grow, flex-basis高的設定 要設定 height flex-grow 怎麼分配剩餘空間假設 flex container 的寬為 1000px並有兩個 flex item，box1 跟 box2 flex-grow 分別為 3 跟 1 flex-basis 皆為 100px 先計算剩餘寬度 剩餘的寬度 = container width - box 的寬加總= 1000px - 200px = 800px 接著把剩餘寬度分配給 box1 及 box2 分配寬度 = flex container 剩餘寬度 * flex-grow / flex-grow 加總box1 分配到的寬度 = 800px * 3 / (1+3) = 600pxbox2 分配到的寬度 = 800px * 1 / (1+3) = 200px 最後分配到的寬度再加回 box 的寬 flex item 寬度 = 分配寬度 + 原寬度box1 寬度 = 600px + 100px = 700pxbox2 寬度 = 200px + 100px = 300px flex-shrink 怎麼收縮不夠的空間假設 flex container 的寬為 1000px並有三個 flex item，box1 跟 box2 跟 box3 flex-shrink 分別為 1 跟 2 跟 3 width 各為 400 先計算超出多少 超出的寬度 = 三個 box 的寬加總 - flex container 的寬= 1200px - 1000px = 200px 計算三個 box 個別收縮多少 收縮寬度 = flex container 超出寬度 * flex-shrink / flex-shrink 加總box1 要收縮的寬度 = 200px * 1 / (1+2+3) = 33.34pxbox2 要收縮的寬度 = 200px * 2 / (1+2+3) = 66.66pxbox3 要收縮的寬度 = 200px * 3 / (1+2+3) = 100px 把算好的收縮再扣回寬度 box1 寬度 = 400 - 33.33 = 366.66pxbox2 寬度 = 400 - 66.66 = 333.34pxbox3 寬度 = 400 - 100 = 300px 延伸閱讀A Complete Guide to Flexbox","link":"/blog/2021/07/05/css-flexbox/"},{"title":"CSS height 的單位有什麼差別？","text":"要讓height可以有效果，height的設定必須是絕對單位（px, rem…）。例如： 123div { height: 300px;} 但是只是設定%的話，會看起來沒效果，原因是%是一個相對單位（相對於父層的幾％） 123div { height: 30%;} 也因為%不是一個絕對單位，所以如果父層沒有指定高度的話，就等於高度沒有設定，即是 0 的不管幾 %，都是 0 。 有一個例外是&lt;html&gt;是可以設定%的。當&lt;html&gt;設定height為 100% 的時候，代表&lt;html&gt;是視窗高度的 100% 。 123html { height: 100%;} 所以如果要讓高度是「視窗高度的幾 % 」的話，就要先把父層都先定義好。 1234567891011121314151617181920&lt;html&gt;&lt;head&gt; &lt;style&gt; html, body { height: 100%; } div { height: 30%; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 另外，有一個跟「視窗高度的幾 % 」一樣效果的絕對單位，不需設定父層的高度，直接這樣設定就好。 123456789101112131415&lt;html&gt;&lt;head&gt; &lt;style&gt; div { height: 30vh; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","link":"/blog/2021/07/08/css-height/"},{"title":"img 標籤與 background-image 屬性的差別","text":"使用時機 如果需要放純圖片，用 img 標籤 如果在圖片前面還可以有其他的元素，用 background 屬性 img 標籤 不設定寬高的話，會直接填滿父層盒模型。也因為這樣有可能會超出螢幕寬度，可以下max-width:100%來限制不要超出畫面 預設 display:inline-block，仔細觀察的話會發現底部會多出約 2~3px 的空間，解決方式是下面兩種擇一 display 設為 block vertical-align 設為 middle background-image 屬性 如果容器沒有東西就會看不到，需要去定義高度 background-image 模擬 img 的滿版方法 簡單來說是用 padding 去撐出高度舉例 圖片尺寸 1170(寬) 780(高) 780 / 1170 = 0.6666666667 123456.background { background-image: url(xxxx); padding-top: 66.67%; background-size: cover; background-position: center center;} 參考資料六角學院 - img 標籤 與 background-image 的使用上差異","link":"/blog/2022/07/19/css-img-and-background-image/"},{"title":"用Docker跑Cypress","text":"執行這些步驟之前，你必須要先有cypress的測試目錄喔。或是可以從這裡抓我做的專案 安裝 (for Windows)由此下載安裝程式 點兩下安裝 安裝完畢後會自動執行，或是請你重新啟動電腦 安裝docker成功! 抓cypress/included的映像檔(image)cypress/included我是抓6.1.0這個版本 terminal1$ docker pull cypress/included:6.1.0 在你的測試目錄裡執行測試terminal12345678# 這是linux指令$ docker run -it -v $PWD:/e2e -w /e2e cypress/included:6.1.0# 這是windows power shell指令$ docker run -it -v ${PWD}:/e2e -w /e2e cypress/included:6.1.0# 這是windows commader指令$ docker run -it -v %cd%:/e2e -w /e2e cypress/included:6.1.0 最後，在你的cypress資料夾裡面會有screenshot跟video的目錄，可以看到紀錄!參考：Install Docker Desktop on WindowsRun Cypress with a single Docker commandCypress Docker Images","link":"/blog/2020/12/15/cypress-in-docker/"},{"title":"Cypress入門筆記(上)","text":"最近在學習測試，選擇了Cypress這個工具，如果你寫過JQuery，你對他的語法會很快上手。以下是研讀官方文件所記錄的筆記，有些理解可能不正確(畢竟母語不是英文)Introduction to Cypress 查詢元素Cypress像JQuery的部分抓DOM的方式跟JQuery很像 Cypress不像JQuery的部分JQuery找不到東西的時候會變成一個空的$()Cypress則是會自動重新找，直到找到、或是找太久timeout了 命令鏈(Chains of Commands)跟元素的互動你可以抓DOM之後，對其做事 1234// 找到input標籤，然後在裡面輸入&quot;this is a book&quot;cy .get('input') .type('this is a book') Asserting About Elements你可以抓DOM之後斷言(Assert) 12345// 找到input標籤，斷言沒有'小明'這個值// 當input裡面沒有小明，結果為passcy .get('input') .should('not.have.value', '小明') Subject Management 每一條命令都是cy.[command]來起頭 有些方法會產生null，就沒辦法串下一句。例如cy.clearCookies() 有些方法可以一直串下去。例如cy.contains() 每個命令都是異步執行 但還是可以做同步執行的事情，只是你要寫在.then()裡面 命令是有順序的 為了讓你做完一條再執行下一條 命令相似Promise 對cypress來說，每條命令都是把promise串下一個promise 命令不相似Promise 複數個Promise可以並行，但複數個命令不能並行 為了保證每次運行的時候都能正確的執行相同的命令才設計成這樣的 無須返回命令的值 因為命令是絕對有順序的Promise，所以你做完就做完了 你不能用.catch來抓失敗的命令 你不能拋出失敗然後使命令繼續執行 只能是通過一條命令，或是一條失敗的命令，就不執行後面的命令了。","link":"/blog/2020/12/18/cypress-intro-note/"},{"title":"Scrum daily meeting 每日會議","text":"\b第一次實際參與 Scrum Team 至今也半年了，平時寫的文章都是介紹技術比較多，但希望可以留下一些跑 Scrum 的紀錄， 或許未來跟不同團隊合作的時候，這個筆記可以當作一個參考。 每日會議的原則這個原則並不是教科書或是誰規定的，而是實際跑過半年的 scrum，並且大家一起不斷迭代調整後的結論，後面會解釋為什麼很重要。 15 分鐘內結束會議 以事情為單位來開會 資訊透明 為什麼要在 15 分鐘內結束會議有一個大前提是，尊重每個人的時間都很重要，所以這個會議的目的是讓大家可以快速的同步進度。 假設有問題需要花比較多時間溝通，可以先快速對過任務，會後再繼續討論。 或是大家都沒問題，提早結束也是可以的。 習慣在有限的時間裡面開會的好處是，大家都在『講重點』。 什麼是『以事情為單位』來開會？先說『以人為單位』的會議是怎樣？相信很多人都有過這樣的經驗，輪到自己報告的時候這樣報告：我昨天做什麼、今天預計要做什麼、什麼事情大概什麼時候會完成… 當我聽到這樣的報告，我真實的感受是，我不在乎別人的工作內容在幹嘛，同樣也沒有人在乎我在幹嘛。 然後這個會議結束後，該解決的問題還是在，不知道大家有沒有發現，這是『以人為單位』的報告方式。 那『以事情為單位』的會議該怎麼做？我們從『以人為單位』的會議進化成『以事情為單位』的過程中，發現了我們對彼此的工作是沒有共鳴的，直到我們做了以下的調整。 Scrum Team 會在每個 Sprint 開始前就決定好要做的 Story 有哪些，所以 Story 就是我們會議時要關注的事情。 會議開始時，成員們會看著 Story 來確認相關的工作項是否遇到困難或需要幫忙，沒問題就往下一項 Story 繼續。 在這個過程當中『誰做什麼事情』並不是要關注的事情，我們要關注的是『任務現在處在什麼狀態』、『如何推進任務』。 說個題外話，我以前覺得 Scrum 為什麼要貼一堆便利貼，直到我們開會的時候都看著這些任務時，我就懂了。 資訊透明資訊透明對 Scrum Team 來說非常重要，要做什麼都是 Scrum Team 一起決定的，所以每個成員都有義務把狀況同步給所有人。 一定要充分揭露遇到的困難及需要協助的地方我覺得這個對華人來說可能是最困難的部分，有些人習慣報喜不報憂，有些人則是覺得自己默默解決問題就好了，不需要別人幫助。 承認遇到困難或是需要幫忙，就好像把自己的弱點攤出來一樣。 但 Scrum Team 是一群人去完成一件事，而不是單靠誰的能力。 我實際的感受也是這樣，沒有人會覺得我需要幫助就認為我能力差，或者我完成什麼事情就很偉大。 結論原本是想要說 Daily meeting 的眉角，不知不覺就好像都在介紹 Scrum。 其實這些原則不一定是要跑 Scrum 才會用到，只要是軟體開發的團隊都很適用吧。","link":"/blog/2022/06/25/daily-meeting/"},{"title":"CSS 選擇器權重 Specificity","text":"CSS 選擇器是如何判斷要套用哪個樣式?常會遇到寫了樣式卻沒有被套用，而樣式沒被套用有兩個可能 沒有選對元素 選對了元素，但蓋不掉之前的樣式以下就來講 選對了元素，但蓋不掉之前的樣式 CSS 有一個規則叫做 SpecificitySpecificity 有三種 id (1,0,0) class (0,1,0) tag (0,0,1) 規則：#id &gt; .class &gt; &lt;tag&gt;簡單來說，如果要蓋樣式的話，用#id會蓋掉.class及&lt;tag&gt;樣式，用.class會蓋掉&lt;tag&gt;樣式。但如果你用.class要蓋.class的話，就是寫在後面的蓋前面的。 Specificity 組合你可以在寫樣式的時候去組合Specificity，這樣更好做樣式覆蓋。 1234567891011121314151617181920&lt;!-- CSS的部分 --&gt;&lt;style&gt; &lt;!-- h1=(0,0,1) --&gt; h1{ color:black; } &lt;!-- .text=(0,1,0) --&gt; .text{ color:blue; } &lt;!-- h1.red=(0,1,1) --&gt; h1.red{ color:red; }&lt;/style&gt;&lt;!-- HTML的部分，H1的文字呈現為color:red; --&gt;&lt;h1 class=&quot;text red&quot;&gt;文字&lt;/h1&gt; 但是，行內樣式 (inline-style)遇到行內樣式，你就算用了#id一樣蓋不掉。 12345678910111213141516171819202122232425&lt;!-- CSS的部分 --&gt;&lt;style&gt; &lt;!-- h1=(0,0,1) --&gt; h1{ color:black; } &lt;!-- .text=(0,1,0) --&gt; .text{ color:blue; } &lt;!-- #title=(1,0,0) --&gt; #title{ color:yellow; } &lt;!-- h1.red=(0,1,1) --&gt; h1.red{ color:red; }&lt;/style&gt;&lt;!-- HTML的部分，H1的文字呈現為color:green; --&gt;&lt;h1 id=&quot;title&quot; class=&quot;text red&quot; style=&quot;color:green;&quot;&gt;文字&lt;/h1&gt; 還有 !important除非在你的樣式加上!important。另外，!important也可以在inline-style中使用。 12345678910111213141516171819202122232425262728&lt;!-- CSS的部分 --&gt;&lt;style&gt; &lt;!-- h1=(0,0,1) --&gt; h1{ color:black; } &lt;!-- .text=(0,1,0) --&gt; .text{ color:blue; } &lt;!-- #title=(1,0,0) --&gt; #title{ color:yellow !important; } &lt;!-- h1.red=(0,1,1) --&gt; h1.red{ color:red; }&lt;/style&gt;&lt;!-- HTML的部分，H1的文字呈現為color:yellow; --&gt;&lt;h1 id=&quot;title&quot; class=&quot;text red&quot; style=&quot;color:green;&quot;&gt;文字&lt;/h1&gt;&lt;!-- HTML的部分，H1的文字呈現為color:green; --&gt;&lt;h1 id=&quot;title&quot; class=&quot;text red&quot; style=&quot;color:green !important;&quot;&gt;文字&lt;/h1&gt; 總結 基本規則是 #id &gt; .class &gt; &lt;tag&gt;。 把其他狀況都考慮進來的話 !important &gt; inline-style &gt; #id &gt; .class &gt; &lt;tag&gt;","link":"/blog/2020/12/21/css-specificity/"},{"title":"Cypress入門筆記(下)","text":"這裡是下半部分的學習筆記，文章最後有一個自己的總結。以下是研讀官方文件所記錄的筆記，有些理解可能不正確(畢竟母語不是英文)Introduction to Cypress 斷言(Assertions) 斷言是描述元素、物件、應用程式的理想狀態。 舉個例子： &lt;button&gt;按下去後， 他會有active的class Cypress寫成： 1234cy .get('button') .click() .should('have.class','active') 另外，如果.active是2秒後才加入button的話，測試仍然能通過！ 12345678// even though we are adding the class// after two seconds...// this test will still pass!$('button').on('click', (e) =&gt; { setTimeout(() =&gt; { $(e.target).addClass('active') }, 2000)}) 因為Cypress是非同步處理，他會等待測試通過(或是timeout使測試失敗)。 斷言的時機有時候最好的測試是不需要斷言，但是沒有明確的斷言就有可能使測試失敗。 但是Cypress有預設的斷言機制，所以不需要每個命令都要有斷言 斷言的預設值你不需要.should()或.and()，它會自動幫你斷言 cy.visit() 期望回傳200 cy.request() 期望收到回應 cy.contains() 期望從DOM找得到內容 cy.get() 期望抓得到DOM .find() 期望抓得到DOM .type() 期望可以輸入 .click() 期望可以按下 .its() 期望可以找到property 你也有可能期望相反的狀態，所以你可以這樣寫： 123cy .get('button') .should('not.exist') 斷言的寫法有兩種 隱式.should()跟.and()他把斷言都丟進cypress的機制裏面去處理了，所以你可以利用命令鍊把它串起來，寫法相對簡短一些 1234cy .get('#header a') .should('have.class', 'active') .and('have.attr', 'href', '/users') 顯式expect如果要寫得很明確，知道每一步在幹嘛，或是針對同一個主題，你有多個斷言 1234cy.get('tbody tr:first').should(($tr) =&gt; { expect($tr).to.have.class('active') expect($tr).to.have.attr('href', '/users')}) 超時(Timeouts)所有的命令都有可能超時。所有的斷言，無論是自己寫的還是預設的，都有相同的超時值。 超時的應用 預設斷言1cy.get('.mobile-nav') 找.mobile-nav 然後等4秒內看有沒有這個DOM 加上其他的斷言1234cy .get('.mobile-nav') .should('be.visible') .and('contain', 'Home') 找.mobile-nav 然後等4秒看有沒有這個DOM 然後等4秒看能不能訪問它 然後等4秒看它有沒有Home這個文字 修改超時1234cy .get('.mobile-nav', { timeout: 10000 }) .should('be.visible') .and('contain', 'Home') 找.mobile-nav 然後等10秒看有沒有這個DOM 然後等10秒看能不能訪問它 然後等10秒看它有沒有Home這個文字 預設超時 cy.visit() 因為他需要等頁面都家載完，預計會需要很多時間，所以預設是60秒 cy.exec() 因為執行系統的命令，例如設定資料庫初始化，可能會花很多時間，所以預設60秒 cy.wait() 實際上有兩種超時，5秒等路由別名，30秒等伺服器回應。 大部分包含DOM的命令，都預設等4秒 總結建議第一次寫Cypress可以先閱讀官方的Introduction to Cypress開始。你就可以知道： 它是如何查詢DOM 甚麼是命令鍊(chains of commands) 甚麼是斷言(Assertions) 命令中的超時機制","link":"/blog/2020/12/22/cypress-intro-note-2/"},{"title":"Git 跨平台開發 未修改的檔案出現異動(換行警告、檔案權限)","text":"嘗試把一個大專案從 SVN 移到 Git 時，發現從 Windows 環境作 git clone 的時候，檔案會莫名奇妙的有異動，而這個異動卻從文件比對看不出有差異。 過程中試了很多方法才終於解決，以下是完整的過程，文章最後紀錄跨平台開發的情境下應該做哪些 Git 設定。 換行警告 “warning: LF will be replaced by CRLF …”在還不知道原因的時候，想說有異動就 git add + git commit，應該就沒問題了吧，結果從 A 電腦提交，B 電腦 clone 下來，又產生了異動。 後來觀察到 git add 時會有警告訊息： 1warning: LF will be replaced by CRLF ... The file will have its original line endings in your working directory. 原來是因為文字檔的換行格式在 Linux 跟 Windows 不同，而貼心的 Git 會自動這樣做： 在 git clone 的時候，Git 會依照作業系統自動轉換文字檔的換行格式，Windows 換行方式是 CRLF 格式，Linux 是 LF 格式。 在 git add 的時候，Git 會自動把文字檔轉成 LF 的格式（所以就會看到上述的警告）。 LF 跟 CRLF 換行格式電腦如果要看得懂文字檔是在哪裡換行，會在文字檔換行的地方加入換行字元。 在 Windows 系統，換行字元是\\r\\n(CRLF) 在 Linux 系統，換行字元是\\r(LF) 因為開發環境同時有 Linux 跟 Windows，在不同的系統上編輯文字檔就會產生不同的換行格式，所以必須統一換行的格式。 最後選擇統一使用 LF 格式，因為： Git 本身是以 LF 為主 工作上主要使用 Linux 為開發機 使用指令： core.autocrlf {option} true commit 的時候把 CRLF 轉為 LF ，checkout 的時候轉換為 CRLF input commit 的時候把 CRLF 轉為 LF，checkout 的時候不轉換 false 不自動轉換 core.safecrlf {option} true 專案不可以 CRLF 跟 LF 混用 false 專案可以 CRLF 跟 LF 混用 warn 專案可以 CRLF 跟 LF 混用，有 CRLF 跟 LF 混用的情況會跳警告 100755 → 100644 ?以為問題已經解決，用任何的編輯器去檢查都確定是 LF 格式了，沒想到還是會出現異動… 後來我在 Gitlab commit 紀錄裡面發現了 100755 → 100644 寫在檔案路徑後面 拿去 Google 後才發現，原來 Git 連檔案權限都要管，最後是把 Git 的權限追蹤設定關起來就完整解決了。 使用指令： core.filemode false 忽略檔案權限變更 true 自動修正檔案權限 跨平台開發的 Git 設定windows: 1234cd {project} # 移到專案目錄git config core.filemode false # 忽略檔案權限變更git config --global core.autocrlf true # 自動修正換行符git config --global core.safecrlf false # 忽略換行字元警告 linux: 1234cd {project} # 移到專案目錄git config core.filemode false # 忽略檔案權限變更git config --global core.autocrlf input # 取出時轉為LFgit config --global core.safecrlf false # 忽略換行字元警告 參考Git 在 Windows 平台處理斷行字元 (CRLF) 的注意事項Git 提示“warning: LF will be replaced by CRLF”令人困擾的 Git AutocrlfGit Autocrlf 與 Safecrlfgit 关于文件权限修改引起的冲突及忽略文件权限的办法git tips: 设置 filemode，避免 NTFS 文件权限变更引起的修改","link":"/blog/2021/12/21/git-cross-os-config-setting/"},{"title":"Git 同步對齊 fork 專案跟原始專案的 commit","text":"使用fork的方式進行開發開發到一個段落時，如果直接推送自己的東西進master，未來要合併回原始專案的時候，很有機會遇到衝突(可能錯過了一些commit導致)；所以先跟原始專案做”對齊”的動作，再推送自己開發的東西會比較保險 情境 bbb從aaa/projectfork出來bbb/project進行開發 aaa/project的master分支有10個commit。 本地的master分支有5個原始commit，3個開發產生的commit。 bbb想要把本地的master分支，跟aaa/project的commit保持一致，再把自己開發的東西一起推送到bbb/project。 步驟 設定原始專案為上游分支 1git remote add upstream aaa/project.git 抓取原始專案的異動 1git fetch upstream 切到master分支 1git checkout master 把upstream/master合併到master分支 1git rebase upstream/master 如果有異動還沒推，先stash起來，做完rebase後再取出 推送 1git push 參考資料Git中同步主干的代码到fork分支里【狀況題】怎麼跟上當初 fork 專案的進度？Stash（暫存）","link":"/blog/2021/05/12/git-rebase-remote-branch/"},{"title":"成為前端工程師一年後的感覺","text":"嗨，我是小艾，我在 2020 年初參加了泰山職訓局的前端班，成功從遊戲開發 PM 轉職前端工程師；到目前為止，作為一名前端工程師已經一年多了。 今年是一個變化多端的一年，經歷了生活型態的改變，像是疫情足不出戶、居家上班；工作上，逐漸抓到自己的節奏，也開始有一些成長。 成為前端工程師一年後究竟是怎樣的轉變，就繼續看下去吧。 冒牌者症候群上半年的我，工作內容都是一些微調、公司的程式碼重構等任務，有空檔就看技術文章或學前端技術(我也忘了都學了些什麼)。 胡亂學習之下，反而懷疑自己是否能勝任前端的工作，冒牌者症候群發作而感到非常迷惘，下定決心要把前端的基礎打好。 學習的方向在上這些課程的過程中我發現，我對 JavaScript 根本不熟… 我對內建的 Array、Object 方法一點都不認識，每次用的時候都會寫錯，查文件也看不太懂。 那些我知道的 js 相關名詞，如: closure, hoisting, scope，都是知道，但沒辦法詳細解釋。 我只是個懂邏輯的人 意識到了問題之後，我就開始拼命的學，也覺得「把 JavaScript 搞懂」是非做不可的事情。 每當看到社群上討論新的工具(如 vite)、哪個酷酷的東西(Tailwind CSS)之類的，我都告訴自己「現在這些還不重要」； 不知道為什麼，總覺得要變成資深的前端，勢必要很懂 JavaScript。 上了哪些課疫情期間，公司宣布全體居家上班，在家比較自在的安排自己的時間，所以工作的空檔安排了前端課程 2021 網頁開發全攻略(HTML, CSS, JavaScript, React, SQL, Node, more) 還有 JavaScript30 的練習。 但恢復正常上班之後，狀態又不一樣了；JS30 寫了三分之一、Udemy 的課還沒上完，我又跑去報六角的JavaScript 工程師養成直播班。 除了跟著老師上課之外，我還寫了很多筆記、針對一個主題如果有總結的部分就寫成 blog 文章，讓自己當作實作練習。 到了年底，總的來說 我看得懂 MDN 在寫什麼 寫了作用域、hoisting、scope chain 等主題的文章 做資料處理的時候會優先使用 array 或 object 的方法 距離懂 JavaScript，總算邁進幾步了。","link":"/blog/2021/12/30/how-i-feel-after-i-being-frontend-developer-one-years/"},{"title":"Javascript Array every() 方法","text":"針對陣列中的每個元素，執行callback，當全部元素都符合條件，就回傳true，否則回傳false 怎麼寫?Array.prototype.every()1234567891011121314151617181920212223const number = [18, 20, 65, 88, 131, 168]// 判斷{array}是否全部的{element}符合{condition}// 1. 把callback寫成function來使用// array.some(callback)function callback(element) { return element === 18}const boolean1 = number.every(callback)console.log(boolean1) // false// 2. 把callback寫在括號內// array.some(function(element){ return condition })const boolean2 = number.every(function(element){ return element &lt;= 10})console.log(boolean2) // false// 3. 把callback寫成箭頭函式// array.some(element =&gt; condition)const boolean3 = number.every(element =&gt; element &lt; 200)console.log(boolean3) // true 參考Array.prototype.every() - JavaScript | MDN","link":"/blog/2021/05/28/js-array-prototype-every/"},{"title":"Javascript Array find() 方法","text":"針對陣列中的每個元素，執行callback，回傳一個符合條件的元素的值，否則回傳undefined 怎麼寫?Array.prototype.find()1234567891011121314151617181920212223242526272829const employee = [ {name:'Amy',department:'AD', phone:1000}, {name:'Betty',department:'IT', phone:1200}, {name:'Mary',department:'PM', phone:1300}, {name:'Susan',department:'MIS', phone:1400}, {name:'Bill',department:'MIS', phone:1405},]// 從{array}找符合{condition}的{element}的值// 1. 把callback寫成function來使用// array.find(callback)function callback(element) { return element.phone === 1200}const value1 = employee.find(callback)console.log(value1) // {name: &quot;Betty&quot;, department: &quot;IT&quot;, phone: 1200}// 2. 把callback寫在括號內// array.find(function(element){ return condition })const value2 = employee.find(function(element){ return element.department === 'MIS'})console.log(value2) // {name: &quot;Susan&quot;, department: &quot;MIS&quot;, phone: 1400}// 3. 把callback寫成箭頭函式// array.find(element =&gt; condition)const value3 = employee.find(element =&gt; element.name === 'Bill')console.log(value3) // {name: &quot;Bill&quot;, department: &quot;MIS&quot;, phone: 1405} 參考Array.prototype.find() - JavaScript | MDN","link":"/blog/2021/05/28/js-array-prototype-find/"},{"title":"Javascript Array findIndex() 方法","text":"針對陣列中的每個元素，執行callback，回傳一個符合條件的元素的索引值，否則回傳-1 怎麼寫?Array.prototype.findIndex()123456789101112131415161718192021222324252627282930const employee = [ {name:'Amy',department:'AD', phone:1000}, {name:'Betty',department:'IT', phone:1200}, {name:'Mary',department:'PM', phone:1300}, {name:'Susan',department:'MIS', phone:1400}, {name:'Bill',department:'MIS', phone:1405},]// 從{array}找符合{condition}的{element}的索引值// 1. 把callback寫成function來使用// array.findIndex(callback)function callback(element){ return element.phone === 1200}const index1 = employee.findIndex(callback)console.log(index1) // 1// 2. 把callback寫在括號內// array.findIndex(function(element){ return condition })const index2 = employee.findIndex(function(element){ return element.department === 'MIS'})console.log(index2) // 3// 3. 把callback寫成箭頭函式// array.findIndex(element =&gt; condition)const index3 = employee.findIndex(element =&gt; element.name === 'Bill')console.log(index3) // 4 參考Array.prototype.findIndex() - JavaScript | MDN","link":"/blog/2021/05/28/js-array-prototype-findIndex/"},{"title":"Javascript Array some() 方法","text":"針對陣列中的每個元素，執行callback，當至少一個元素符合條件，就回傳true，否則回傳false 怎麼寫?Array.prototype.some()1234567891011121314151617181920212223const number = [18, 20, 65, 88, 131, 168]// 判斷{array}是否至少有一個{element}符合{condition}// 1. 把callback寫成function來使用// array.some(callback)function callback(element) { return element === 65}const boolean1 = number.some(callback)console.log(boolean1) // true// 2. 把callback寫在括號內// array.some(function(element){ return condition })const boolean2 = number.some(function(element){ return element &lt; 20})console.log(boolean2) // true// 3. 把callback寫成箭頭函式// array.some(element =&gt; condition)const boolean3 = number.some(element =&gt; element &gt; 200)console.log(boolean3) // false 參考Array.prototype.some() - JavaScript | MDN","link":"/blog/2021/05/28/js-array-prototype-some/"},{"title":"Javascript Array slice() 方法","text":"拷貝陣列的資料。 會回傳新的陣列，不會改變原始陣列。 怎麼寫?Array.prototype.slice()12345678910111213141516const fruit = ['apple','banana','coconut','durian','grape','kiwi']// array.slice(start,end)// 拷貝{start}到{end}之前的資料(不包含end)const array1 = fruit.slice(0,3)console.log(array1) // [&quot;apple&quot;, &quot;banana&quot;, &quot;coconut&quot;]// array.slice(start)// 拷貝{start}之後所有資料const array2 = fruit.slice(2)console.log(array2) // [&quot;coconut&quot;, &quot;durian&quot;, &quot;grape&quot;, &quot;kiwi&quot;]// array.slice(-n)// 拷貝倒數{-n}個資料const array3 = fruit.slice(-2)console.log(array3) // [&quot;grape&quot;, &quot;kiwi&quot;] 若slice(n)的n為0或是undefined，則會從0開始拷貝陣列。 參考Array.prototype.slice() - JavaScript | MDN","link":"/blog/2021/05/27/js-array-prototype-slice/"},{"title":"JavaScript 陣列排序 sort","text":"預設排序array.sort()是以字串的 Unicode 編碼位置來排序陣列中的元素。 123let fruit = ['Orange', 'Banana', 'Apple', 'Cherry']fruit.sort()console.log(fruit); // [ 'Apple', 'Banana', 'Cherry', 'Orange' ] 自訂義排序若用sort()來排序「數字」，我們也會得到「照字母排序」的結果。 下面的執行結果為100排在25之前，因為以字母順序來看，1是排在2之前。 123let numbers = [ 25, 3, 100, 67, 45, 7]numbers.sort()console.log(numbers); // [ 100, 25, 3, 45, 67, 7 ] 要如何使用自訂義排序？在sort()帶入比較方法，而比較方法需要自己定義。 原則上： 比較方法應傳入兩個參數，用來做比較。 比較方法應回傳正、負值，或是 0，用來決定排序。 以下面的程式碼為例： 如果compare(a, b)回傳 正的值(大於 0)**，就把 a 排在 b **後面。 如果compare(a, b)回傳 負的值(小於 0)**，就把 a 排在 b **前面。 如果compare(a, b)回傳 0，就不動順序。 123456789101112131415161718let numbers = [ 25, 3, 100, 67, 45, 7]function compare(a, b) { if(a &gt; b) { return 1 // 如果 a 大於 b ，就把 a 排在 b 後面 } if (a &lt; b) { return -1 // 如果 a 大於 b ，就把 a 排在 b 前面 } return 0 // a = b ，就不動}// 把 compare function 傳進去 numbers.sort()numbers.sort(compare)console.log(numbers); // [ 3, 7, 25, 45, 67, 100 ] 簡單應用自訂排序數字由小到大排序 當回傳a - b是 4 - 3 = 1，等於回傳大於 0的數字，代表 4 要排在 3 後面。 當回傳a - b是 2 - 4 = -2，等於回傳小於 0的數字，代表 2 要排在 4 前面。 當回傳a - b是 100 - 100 = 0，等於回傳 0，代表 100 跟 100 不動。 12345678910let numbers = [ 2, 4, 3, 100, 1, 100]function compare(a, b) { return a - b}// 把 compare function 傳進去 numbers.sort()numbers.sort(compare)console.log(numbers); // [ 1, 2, 3, 4, 100, 100 ] 依照物件的值排序 compareName(a, b) 與 compareAge(a, b) 傳入的 a 跟 b，代表 person 陣列中的物件 compareName(a, b)比較姓名的方法 a.name 跟 b.name，代表從物件中取出 name 的值 若比較的方法是拿字串進行比較，會根據第一個不同字元的 ASCII 編碼進行大小比較。例如： Banana 與 Berry 比較，第一個位元都是 B，就會從第二個位元 a 跟 e 開始比較。 compareAge(a, b) 比較年齡的方法 a.age 跟 b.age，代表從物件中取出 age 的值 123456789101112131415161718192021222324252627282930let person = [ { name : 'Aidan Jackson', age: 75 , phone: '576-7883'}, { name : 'Mia Abraham', age: 26 , phone: '913-9939'}, { name : 'Harry King', age: 50 , phone: '173-8232'}, { name : 'Dean Burton', age: 50 , phone: '394-4192'},]// 比較姓名的方法function compareName(a, b){ if (a.name &lt; b.name) { return -1; } if (a.name &gt; b.name) { return 1; } return 0;}// 比較年齡的方法function compareAge(a, b){ return a.age - b.age}// 照姓名排序let personSortByName = person.sort(compareName)console.log(personSortByName);// 照年齡排序let personSortByAge = person.sort(compareAge)console.log(personSortByAge); 小測驗也可以用上述的例子，來做出「照電話號碼排序」的方法喔~ 參考資料JavaScript 数组排序Array.prototype.sort() - JavaScript | MDN","link":"/blog/2021/10/25/js-array-prototype-sort/"},{"title":"Javascript Array splice() 方法","text":"對陣列做刪除或插入資料。 會改變原始陣列的內容 怎麼寫?Array.prototype.splice()12345678910111213141516const fruit = ['apple','banana','coconut','durian','grape','kiwi']// array.splice(start,n)// 從第{start}開始，刪除{n}筆資料fruit.splice(1,2)console.log(fruit) // ['apple','durian','grape','kiwi']// array.splice(start,0,item)// 在{start}的位置插入{item}fruit.splice(1,0,'cherry')console.log(fruit) // ['apple','cherry','durian','grape','kiwi']// array.splice(start,n,item)// 從第{start}開始，刪除{n}筆資料，並在{start}的位置插入{item}fruit.splice(1,2,'berry')console.log(fruit) // [&quot;apple&quot;, &quot;berry&quot;, &quot;grape&quot;, &quot;kiwi&quot;] 參考Array.prototype.splice() - JavaScript | MDN","link":"/blog/2021/05/27/js-array-prototype-splice/"},{"title":"JavaScript Bind Call Apply","text":"認識 bind, call, apply 這三個方法之前，先說說 function 與 this。 function 是 object在 JavaScript 裡，幾乎所有的東西都是 object，function 也不例外。 this keywordthis 就是 this 所在的 object，下面的例子，this.age 的 this 指的就是 Bolas 這個物件。 123456let Bolas = { age: 18, sayAge() { console.log(&quot;Bolas's age is &quot; + this.age + &quot; years old&quot;) }} 雖然 function 也是 object，但如果 this 在 function 裡， this 指的是 window 12345function hello(){ console.log(this)}hello() // window Bind, Call, Apply 的用途如果我們需要改變 function 的 this，可以用 function 繼承的方法：bind, call, apply，來達到改變 this 的指向。這三個方法的用途都是在重新綁定 function 的 this，差別在於寫法不一樣。 實際應用 有各種放錢 money 的地方：口袋 pocket、皮夾 wallet、銀行 bank 有查詢 money 的功能：getMoney() 有更新 money 的功能：updateMoney() 我們如果直接使用 getMoney 或 updateMoney 會因為 this 是指向 window 而無法正常使用。接下來要用到 bind, call, apply 來改變 this。 1234567891011121314151617181920212223let pocket = { money: 325,}let wallet = { money: 2000,}let bank = { money: 300400,}// 查詢function getMoney() { console.log(this.money)}// 更新function updateMoney(location, numberOfMoney) { let total = this.money + numberOfMoney console.log(`${location}原本有${this.money}元。存了${numberOfMoney}進去，現在有${total}元。`) this.money = total} bind 的寫法用 bind 來改變 this 指向皮夾 wallet。 bind 會需要用新的變數來裝，會寫比較多程式碼。 1234567891011// Function.prototype.bind() 寫法// let newFunction = originFunction.bind(thisArg)// newFunction(parameter1, parameter2, ...);// 查詢let checkWalletMoney = getMoney.bind(wallet)checkWalletMoney() // 2000// 更新let updateMoneyIntoWallet = updateMoney.bind(wallet)updateMoneyIntoWallet('皮夾', 300) // 皮夾原本有2000元。存了300進去，現在有2300元。 call 的寫法用 call 來改變 this 指向口袋 pocket。 個人覺得是最方便的寫法 12345678// Function.prototype.call() 寫法// originFunction.call(thisArg, parameter1, parameter2, ...)// 查詢getMoney.call(pocket) // 325// 更新updateMoney.call(pocket, &quot;口袋&quot;, 500) // 口袋原本有325元。存了500進去，現在有825元。 apply 的寫法用 apply 來改變 this 指向銀行 bank。 要注意的是 apply 接受的參數為陣列，所以要把帶入的參數用陣列裝起來 123456789// Function.prototype.apply() 寫法// originFunction.apply(thisArg, [parameter1, parameter2, ...])// *** parameter is an array// 查詢getMoney.apply(bank) // 300400// 更新updateMoney.apply(bank, [&quot;銀行&quot;, 80000]) // 銀行原本有300400元。存了80000進去，現在有380400元。","link":"/blog/2021/08/24/js-bind-call-apply/"},{"title":"JavaScript 閉包 Closure","text":"當 function 執行完之後，會進行記憶體釋放，也就是說 function 內的變數就再也找不到了。但如果希望留住 function 內的資料狀態，可以透過閉包的手法。 如何做出閉包? 宣告一個 function functionA functionA 裡面宣告要保留的資料 count = 0，接著回傳 functionB functionB 裡面做 count = count + 1，並回傳 count 宣告一個變數 a，把 functionA() 賦予值給這個變數 a 12345678910111213function functionA() { var count = 0 return function functionB() { count = count + 1 return count }}var a = functionA()console.log(a()) // 1console.log(a()) // 2console.log(a()) // 3 最後我們就得到了變數 a，a 的值是 functionB(){ ... return count }，所以 a 現在也是一個 function 了。接著我們執行 a() 的時候，會得到 functionB 回傳的值；如果連續執行三次 a()，分別會得到 1、2、3。 執行結果居然不是 1、1、1，這是為什麼？ 成為閉包的關鍵將「functionA 執行的結果」賦予值給 a，此時 a 的值是 「functionB 這個函式」。因為 functionB 執行的時候會用到 count，造成「functionA 一直處在執行中，執行不完無法釋放」，所以 count 的狀態就被保留下來了。 由於「functionA 一直處在執行中，執行不完無法釋放」，讓 count 的資料狀態可以保留下來，也就意味著記憶體會一直被佔用。 實用的閉包 再宣告一個變數 b，把 functionA() 賦予值給這個變數 b 123456// 前略var b = functionA()console.log(b()) // 1console.log(b()) // 2console.log(b()) // 3 跟先前宣告的變數 a 一樣，b 的值是 functionB(){ ... return count }，再連續執行三次 b()，分別會得到 1、2、3。 這裡會發現 a 跟 b 的雖然都是 functionB(){ ... return count }，但執行的結果不會共享。 這是因為宣告 a 跟 b 的時候，是「各自」指向functionA 執行的結果，所以資料狀態就獨立出來了。 以上程式碼用白話來說就是：a 跟 b 各自拿到了「同樣規格」的計數器a 按了三次，分別顯示 1、2、3b 按了三次，分別顯示 1、2、3 如此一來，更可以透過閉包的手法，來產出「同樣功能規格」的 function，給不同的對象使用。 最後來個範例情境有一間熱炒 99 元的餐廳，每次計算金額的時候都會看每桌點了幾盤，由於熱炒店常常會有加點的情形，所以每次加點都還需要再次計算金額。 Codepen See the Pen Closure by BolasLien (@bolaslien) on CodePen. 參考資料閉包 Closure - 函式以及 This 的運作 - 六角學院 js 核心篇重新認識 JavaScript: Day 19 閉包 ClosureJavaScript Scope Chain 與 Closure","link":"/blog/2022/06/02/js-closure/"},{"title":"JavaScript 如何複製陣列？","text":"做陣列資料裡的時候，有時候不希望異動到原始的資料，所以會將資料複製一份來用。 但問題是，在 JavaScript ，如果直接把陣列賦值給新的變數來用，一樣會改到原本的資料。 舉個例子，宣告一個變數 copy，並且把已存在的陣列 fruit 賦值給 copy，並且在 copy 新增一筆資料。 123456let fruit = [&quot;apple&quot;,&quot;banana&quot;];let copy = fruit;copy.push(&quot;cherry&quot;)console.log(fruit); // [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]console.log(copy); // [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] 會發現原本的陣列 fruit 也多出了一筆資料。 這是因為 JavaScript 裡面，只要變數存的資料類型是物件，那這個變數就是指向物件的記憶體位置，而不是值。 另外，即使資料是 Array ，但對 JavaScript 來說 Array 也是物件，所以 copy、fruit 都指向了同一個記憶體位置，所以改動了 copy 等於改動 fruit。 123let fruit = [&quot;apple&quot;,&quot;banana&quot;];console.log(typeof fruit) // object 複製陣列的方法 Array.from() 這個方法會建立一個新陣列。 展開運算子 ... 這個寫法是把物件展開，做成陣列的話，用[]包起來。 123456789let fruit = [&quot;apple&quot;,&quot;banana&quot;];let copy1 = Array.from(fruit);let copy2 = [ ...fruit ];copy1.push(&quot;cherry&quot;)copy2.push(&quot;coconut&quot;)console.log(fruit); // [&quot;apple&quot;, &quot;banana&quot;]console.log(copy1); // [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]console.log(copy2); // [&quot;apple&quot;, &quot;banana&quot;, &quot;coconut&quot;]","link":"/blog/2021/09/01/js-how-to-copy-an-array/"},{"title":"JavaScript 如何區分表達式(Expression)與陳述式(Statement)?","text":"JavaScript 怎麼理解我們輸入的東西?就跟我們的對話一樣，透過「單詞」拼湊出來「一句話」，這樣我們就可以知道對方想要表達的事情是什麼。 而 JavaScript 則是分析你寫的程式碼是「表達式」還是「陳述式」，來知道你想要做的事情是什麼。 用中文對話來理解表達式範例12小明: 你今年幾歲?小華: 12 歲 「你今年幾歲」、「你的生日幾月幾號」、「你知道桌上有幾個東西嗎?」這種一定有答案的句子，我們可以說這是表達式。 陳述式範例12小美: 你像一隻貓咪，我猜不透你！小華: (已讀不回) 「你是貓咪」、「你很累的樣子」、「你如果看到西瓜」這種描述的句子，我們可以說這是陳述式。 日常對話12媽媽: 你去幫我買西瓜，如果看到西瓜，就買三個西瓜，沒有的話，就買三個雞蛋小華: 好! 在日常對話中，會出現「表達式」跟「陳述式」混用的情形，寫程式也是一樣會有混用的情形。 JavaScript 是哪些東西構成表達式與陳述式?表達式有哪些「形式」？詳細可以看這 值 賦予值 各種運算子(算術運算子、相等運算子、關係運算子、邏輯運算子、三元運算子) 呼叫函式 陳述式有哪些「形式」？詳細可以看這 宣告(var, function) 流程控制(Block, if else, switch) 迴圈(for, for…in) 其他(import, export) 差異表達式：在JS中描述結果的語法，比如說運算結果、或是給變數賦予值。陳述式：在JS中描述一件事情的語法，比如說流程控制、宣告一個變數。 試試看123456789101112131 + 1; // 1 + 1有運算結果，所以是表達式。var a = 1;// var a = 1 陳述式與表達式都有。// var a 是宣告一個變數a，是描述一件事，所以是陳述式。// a = 1 是給a賦予1這個值，是描述一個結果，所以是表達式。if(isRaining === true) { withUmbrella();}// isRaining === true 有一個判斷的結果，所以是表達式// if(){} 是在說，如果成立就做甚麼...所以是陳述式// withUmbrella() 是表達式，因為執行一個function會回傳結果，所以是表達式 參考JavaScript 表達式觀念及運用 - JS Expression | 卡斯伯 Blog - 前端，沒有極限運算式與運算子 - JavaScript | MDN陳述式與宣告 - JavaScript | MDN","link":"/blog/2021/10/27/js-expression-and-statement/"},{"title":"別再只會用 console.log 了","text":"介紹一些開發時好用的方法，別再只會用console.log了 Break on在瀏覽器(chrome)的開發工具中，可以對標籤下斷點，當程式去改變標籤的時候，瀏覽器就會捕捉是誰改變的。 常見的印出訊息的方式。 直接印出來 插入字串 設定樣式 console.log1234567891011// 常見的用法console.log('嗨!')// 插入字串// %s 是字串的變數console.log('這是 %s ', '💩')// 讓訊息可以有樣式// %c後面的文字都會套用樣式console.log('%c注意!', 'color:red; font-size:30px;')console.log('謝謝你的%c注意!', 'color:red; font-size:20px;') 除了console.log，你還可以…console.table()可以用表格的方式呈現物件內容 console.table123456let a = [ { first: 'Galileo', last: 'Galilei', year: 1564, passed: 1642 }, { first: 'Johannes', last: 'Kepler', year: 1571, passed: 1630 },]console.log(a)console.table(a) 帶有圖示的console console.warn()帶有警告圖示⚠️及樣式的訊息 console.error()帶有錯誤圖示❌及樣式的訊息 console.info()帶有資訊圖示ℹ️的訊息 console.warn console.error console.info12345678// 警告console.warn('請注意腳下!')// 錯誤console.error('Shit! 踩到💩了!')// 資訊console.info('💩 這是一坨像冰淇淋🍦上的奶油一樣盤旋着的棕色大便') 測試console.assert()如果帶入的值為false，就把訊息印出來 console.assert()12345// falseconsole.assert(1===2,'1不可能等於2') // 1不可能等於2// trueconsole.assert(1===1,'不可能錯啊') 清除consoleconsole.clear()會把所有console都清掉，並且顯示console was cleared console.clear12345console.log('123')console.log('456')console.log('789')console.clear() // console was cleared 看DOM的詳細內容console.dir()可以把DOM當物件展開。 MDN建議不要用在生產環境 console.dir()12345&lt;p&gt;測試&lt;/p&gt;const p = document.querySelector('p')console.log(p) // &lt;p&gt;測試&lt;p&gt;console.dir(p) // p HTMLParagraphElement 把log群組起來如果印出的訊息需要分類，可以用console.group()與console.groupEnd()來把console.log()包起來 預設是會把群組訊息展開，如果要預設收合起來，就要用console.groupCollapsed() console.group1234567// console.group(群組名字)console.group('馬鈴薯')console.log('價格 18元');console.log('重量 120g');console.log('買5送1');// console.groupEnd(群組名字)console.groupEnd('馬鈴薯') 計算log出現的次數console.count()可以印出訊息以及他出現的次數。 console.count12345678console.count('洋蔥') // 洋蔥: 1console.count('馬鈴薯') // 馬鈴薯: 1console.count('洋蔥') // 洋蔥: 2console.count('洋蔥') // 洋蔥: 3console.count('馬鈴薯') // 馬鈴薯: 2console.count('馬鈴薯') // 馬鈴薯: 3console.count('洋蔥') // 洋蔥: 4console.count('洋蔥') // 洋蔥: 5 追蹤某個操作經過的時間用console.time()開始計時，直到console.timeEnd()為止，會印出經過的操作耗費多少毫秒(每個人電腦不同，結果會不同) console.time12345console.time('for')for(let i = 0; i&lt;= 50; i++){ console.log(i);}console.timeEnd('for') // for: 2.09423828125 ms 參考[javascript30] 09 - Dev Tools DominationConsole - Web APIs | MDN","link":"/blog/2021/06/08/js-dev-tools/"},{"title":"JavaScript Scope Chain 與 Closure","text":"Scope 到底是指哪裡？Scope 是變數的有效範圍。 function 裡面是 local，指的是在 local 這個範圍裡面有效。 function 外面是 global，指的是在 global 這個範圍裡面有效。 所以 Scope chain 是指？Scope chain 像是一張地圖。 Scope chain 生成在程式的創建階段，所以在執行之前就已經決定好 function 的作用域。換句話說，程式碼寫完就決定好作用域了。 如果使用了 function 外面宣告的變數，JavaScript 還是能依照 Scope chain 去 function 外面找到正確的變數來使用。如果外面還是找不到，就去外面的外面 … 直到找到它，找不到的話就拋出錯誤。 那 closure 呢？要理解 closure 要先知道作用域是已經決定好的了。 我們知道在 function 裡面的變數對 function 外面的作用域是沒有意義的，它會在呼叫 function 的時候創建，function 執行完之後釋放掉。所以不管我們呼叫幾次，function 裡面的變數都會重新建立。 舉個例子，在 function 裡面宣告一個變數 count，每次呼叫counter()，count 的值都會從 0 開始。 123456789function counter(){ let count = 0; count = count + 1 return count}console.log(counter()) // 1console.log(counter()) // 1console.log(counter()) // 1 我們也知道 function 裡面可以使用 function 外面的變數，因為該變數的作用域是 global 了，它不會隨著 function 執行完之後被釋放掉。 試著把 count 移到 global。每次呼叫 counter() ， count 的值都會累加。 123456789let count = 0;function counter(){ count = count + 1 return count}console.log(counter()) // 1console.log(counter()) // 2console.log(counter()) // 3 但如果不希望 count 的值暴露在 global，又希望 count 的值會累加，可以怎麼做？ 用第一個例子，把 return count 的地方，用 return function(){} 包起來；再把 counter() 存成一個變數 myCounter。 12345678910111213141516function counter(){ let count = 0 // 用 return function(){} 包起來 return function(){ count = count + 1 return count }}// 再把 counter() 存成一個變數 myCounterlet myCounter = counter()// 神奇的事情發生了console.log(myCounter()); // 1console.log(myCounter()); // 2console.log(myCounter()); // 3 所以為什麼 count 可以累加了？來看 let myCounter = counter() 這一行發生了什麼事。 執行 counter() function counter() 的作用域被產生了 回傳 function(){...} 存到了 myCounter 正常來說 function 執行完就釋放了，但是把 執行counter() 存入 myCounter 變數，讓 function counter 沒有被釋放掉，而是被保留下來了。所以後續我們執行 myCounter 的時候，就會讓 count 累加。 這個現象就叫做 closure。 參考閉包重新介紹JavaScriptfunction closures重新認識 JavaScript: Day 19 閉包 Closure所有的函式都是閉包：談 JS 中的作用域與 Closure","link":"/blog/2021/08/26/js-scope-chain-and-closure/"},{"title":"JavaScript 比對字串的幾個方法","text":"在處理要允許的host時，用到了幾個方法做了筆記，以下也會提到一些要注意的地方。 直接用 ===12345let allowHost = 'google.com'if(windows.location.host === allowHost){ //....} windows.location.host要跟條件「絕對一致」的話，直接用===來判斷吧；但是如果不是…那就繼續看下去吧。 是否含有某個字串 String.prototype.includes()12345let allowHost = 'google.com'if(windows.location.host.includes(allowHost)){ //....} 可以把字串丟入includes()進行處理，若windows.location.host裡面有包含跟條件一致的字串，會回傳ture，但如果找不到就會回傳false。 遺憾的是IE並不支援includes() 所以我們必須繼續看下去。 找到字串所在的索引值 String.prototype.indexOf()123456789101112let allowHost = 'google.com'if(windows.location.host.indexOf(allowHost) &gt;= 0){ //....}// orif(windows.location.host.indexOf(allowHost) !== -1){ //....} 把字串丟入indexOf()進行處理，若windows.location.host裡面有包含跟條件一致的字串，會回傳第一個被找到的索引值，但如果都找不到就會回傳-1。 為了支援大部分的瀏覽器會使用indexOf()來做比對，但如果要比對的host是個陣列的話，可以再搭配some()來做處理。 要比對陣列裡的元素，搭配 Array.prototype.some()123456789101112let allowHost = ['google.com','yahoo.com','github.com']if(allowHost.some(e=&gt; window.location.host.indexOf(e) &gt;= 0)){ //....}// orif(allowHost.some(e=&gt; window.location.host.indexOf(e) !== -1)){ //....} 使用some()可以尋訪陣列中的每個元素，需要給some()一個callback來進行處理，只要有一個符合條件的callback就會回傳ture，都沒有符合就回傳false。 如此一來就可以判斷多個host。","link":"/blog/2021/03/25/js-saveral-way-for-compare-strings/"},{"title":"JavaScript 用邏輯判斷 ||(OR) 及 &amp;&amp;(AND) 來改寫 if (短路求值 Short-circuit evaluation)","text":"先講結論：||、 &amp;&amp; 可以幫助程式碼變得更短。 用 ||、 &amp;&amp; 來改寫if 用 || 來設定變數的預設值 用 &amp;&amp; 來檢查物件屬性是否存在 ||(OR) 及 &amp;&amp;(AND) 介紹||(OR) 在判斷多個條件中，只要一個為true時，就會回傳true。 1234567let a = 2let b = 4console.log(a &gt; 1 || b &gt; 2) // trueconsole.log(a &gt; 3 || b &gt; 2) // trueconsole.log(a &gt; 1 || b &gt; 5) // trueconsole.log(a &gt; 3 || b &gt; 5) // false &amp;&amp;(AND) 在判斷多個條件中，必須全部為true時，才會回傳 true。 1234567let a = 2let b = 4console.log(a &gt; 1 &amp;&amp; b &gt; 2) // trueconsole.log(a &gt; 3 &amp;&amp; b &gt; 2) // falseconsole.log(a &gt; 1 &amp;&amp; b &gt; 5) // falseconsole.log(a &gt; 3 &amp;&amp; b &gt; 5) // false 然而我們可以用OR、AND去處理非Boolean的物件。在Javascript中，非Boolean的物件是可以被判斷為真值(truthy)，但除了幾個物件是有被定義為假值(falsy)： null NaN 0 空字串 (&quot;&quot; 或 '' 或 ``) undefined 在if裡面，真值(truthy)可以轉換為true，假值(falsy)可以轉換為false來進行OR或AND判斷。 舉例來說，我們可以判斷宣告的變數裡面有沒有值。 123456let a = null // falsylet b = '12345' // truthyif(a || b) { console.log('其中一個有東西!!') // 其中一個有東西!!} 但不在if裡面，直接印出來的話會發生甚麼事情? 1234let a = null // falsylet b = '12345' // truthyconsole.log(a || b) // 12345 為何這個例子印出了12345，而不是true？因為OR、AND可以處理非Boolean的物件，所以稍微修改一下一開始的解釋： ||(OR) 在判斷多個條件中，只要一個為 true 真值(truthy) 時，就會回傳 true 該物件。 &amp;&amp;(AND) 在判斷多個條件中，必須全部為 true 真值(truthy) 時，才會回傳 true 該物件。 短路求值 Short-circuit evaluation短路求值在維基百科的解釋： 只有當第一個運算數的值無法確定邏輯運算的結果時，才對第二個運算數進行求值。例如，當AND的第一個運算數的值為false時，其結果必定為false；當OR的第一個運算數為true時，最後結果必定為true，在這種情況下，就不需要知道第二個運算數的具體值。 在MDN的解釋： The logical AND expression is evaluated left to right, it is tested for possible “short-circuit” evaluation using the following rule: (some falsy expression) &amp;&amp; expr is short-circuit evaluated to the falsy expression; Short circuit means that the expr part above is not evaluated, The logical OR expression is evaluated left to right, it is tested for possible “short-circuit” evaluation using the following rule: (some truthy expression) || expr is short-circuit evaluated to the truthy expression. Short circuit means that the expr part above is not evaluated, 大概翻譯： AND 表達式是從左計算到右，在短路求值的計算中，如果左邊的表達式計算出來是 假值(falsy) ，那右邊的表達式就不會計算(執行)。 OR 表達式是從左計算到右，在短路求值的計算中，如果左邊的表達式計算出來是 真值(truthy) ，那右邊的表達式就不會計算(執行)。 依照這樣的邏輯，我們就可以用來改寫if，或是更進階的應用。 額外補充AND跟OR的優先順序是AND優先，如果混著用的話就會先做AND from MDN12true || false &amp;&amp; false // returns true, because &amp;&amp; is executed first(true || false) &amp;&amp; false // returns false, because operator precedence cannot apply 短路求值應用如果data沒有資料的時候，要印出「沒有data」的訊息。 123456789let data = null// if的寫法if (!data) { console.log('沒有data') // 沒有data}// || 的寫法data || console.log('沒有data') // 沒有data 如果data有資料的時候，要把資料印出來。 123456789let data = '12345'// if的寫法if(data) { console.log(data) // 12345}// &amp;&amp;的寫法data &amp;&amp; console.log(data) // 12345 不知道data有沒有值，沒有的話就給預設值。 12345678function getData(data) { data = data || { bar: 456} console.log(data)}getData() // {bar: 456}getData({ foo: 123 }) // {foo: 123} 如果person有job的屬性，就要印出person的job。 1234567891011121314151617const person1 = { name: 'Amy', age: '38', job: 'teacher'}const person2 = { name: 'Betty', age: '18',}function getPersonJob(person) { person.job &amp;&amp; console.log(`${person.name} 的工作是 ${person.job}`)}getPersonJob(person1) // Amy 的工作是 teachergetPersonJob(person2) 延伸閱讀Logical AND (&amp;&amp;) - JavaScript | MDNLogical OR (||) - JavaScript | MDN短路求值JavaScript基本功修練：Day9 - 短路求值與條件運算子的應用JavaScript: What is short-circuit evaluation? | by Brandon Morelli | codeburstJS 中 if / if…else…替换方式","link":"/blog/2021/06/18/js-short-circuit-evaluation/"},{"title":"JavaScript 什麼是強制轉型(type coercion)、以及如何轉型？","text":"強制轉型是在轉什麼?「轉型」就是將資料型別轉換成另一種資料型別。 JavaScript 資料型別 基本型別 Primitive Boolean Null Undefined Number String Symbol 物件型別 Object Array 轉型的規則以下的表格為輸入的資料型別及轉型後的結果： ToBoolean 輸入的資料型別 轉為 Boolean 的結果 Undefined 回傳 false Null 回傳 false Boolean 輸入什麼就回傳什麼 Number 如果是+0 -0 或 NaN 就回傳 false，否則就回傳 true String 如果是空字串就回傳 false(因為字串長度為 0)，否則回傳 true Symbol 回傳 true Object 回傳 true ToNumber 輸入的資料型別 轉為 Number 的結果 Undefined 回傳 NaN Null 回傳 0 Boolean 如果是 true 就回傳 1，如果是 false 就回傳 0 Number 輸入什麼就回傳什麼 String 如果可以轉數字就回傳 轉數字後的資料，否則回傳 NaN Symbol 拋出 TypeError Object 執行下列步驟來產生回傳值 1. 用 valueOf() 取得基本型別值，接著用 toString() 轉為字串 2. 把轉字串的值再轉數字，回傳 轉型後的值 ToString 輸入的資料型別 轉為 String 的結果 Undefined 回傳 'undefined' Null 回傳 'null' Boolean 如果是 true 就回傳 'true' 如果是 false 就回傳 'false' Number 1. 如果是 NaN 就回傳 'NaN'2. 如果是 +0 或 -0 就回傳 '0'3. 如果是 小於零 就回傳 負數字串。例如：-100 轉型後為'-100'4. 如果是 無限大 就回傳 'Infinity'點我看更多 String 輸入什麼就回傳什麼 Symbol 拋出 TypeError Object 執行下列步驟來產生回傳值 1. 用 toString() 轉為字串，如果無法轉字串就用valueOf()，再將結果toString()轉型 2. 回傳 轉型後的值 💡 詳細規則請點此看文件，不過我想大部分的人應該不會看… 發生「強制轉型」的情境 使用 JavaScript 的方法，把變數轉換為另一個型別。 把不同資料型別的變數拿來做運算，JavaScript 會很貼心的把變數轉換為同一個型別，才進行運算。 💡 使用 JavaScript 方法來轉型，稱為「顯式轉型」(explicit type coercion)；💡 JavaScript 幫你轉，稱為「隱式轉型」(implicit type coercion) 顯式轉型 explicit type coercion (使用 JavaScript 方法來轉型)如果我們希望把現在的資料型別，轉換成另一種資料型別，就可用 JavaScript 提供的方法來「手動」轉換。 String使用 String() 來把數字轉字串。 可以把數字、值、變數，甚至是表達式轉成字串。 💡 把表達式轉字串的執行順序是先算完再轉型，所以把表達式轉型會得到運算結果的字串。 1234let x = 5 // x 原本是數字String(x) // '5' 把變數轉為字串String(123) // '123' 把值轉為字串String(100 + 200) // '300' 把表達式轉為字串 另外，用 toString() 的結果也是一樣。 1234let x = 5 // x 原本是數字x.toString() // '5' 把變數轉為字串(123).toString() // '123' 把值轉為字串(100 + 200).toString() // '300' 把表達式轉為字串 其他資料型別 123456String(null) // 'null'String(undefined) // 'undefined'String(true) // 'true'String(false) // 'false'String([]) // ''String({}) // '[object Object]' Number使用 Number() 來把字串轉數字。 如果是數字的字串，會轉為數字 如果是空字串，會轉為0 如果不是上面兩種，就會轉為NaN 1234Number('123') // 123Number('3.1415') // 3.1415Number('') // 0Number('hello') // NaN 其他資料型別 123456Number(null) // 0Number(undefined) // NaNNumber(true) // 1Number(false) // 0Number([]) // 0Number({}) // NaN Boolean用 Boolean() 轉型為布林值 只要不是 falsy，都回傳 true 💡 falsy 是什麼？ 1234567891011121314151617181920// falsy valuesBoolean('') // falseBoolean(0) // falseBoolean(-0) // falseBoolean(NaN) // falseBoolean(null) // falseBoolean(undefined) // falseBoolean(false) // false// numberBoolean(123) // trueBoolean(-123) // true// stringBoolean('123') // trueBoolean('hello') // true// 空陣列、空物件Boolean({}) // trueBoolean([]) // true 用 Number() 來把布林值轉為數字 12Number(true) // 1Number(false) // 0 用 String() 來把布林值轉為字串 12String(true) // 'true'String(false) // 'false' Date把 Date 物件轉型 轉成數字會得到 timestamp 轉成文字會得到 ISO 8601 格式的字串 轉成布林值會得到 true 💡 淺談 JavaScript 中的時間與時區處理 123456789101112131415161718let d = new Date()// 1. 使用 Number() 來把日期轉數字。Number(d) // 1635415168807// Date 物件本身就有的 getTime() 也可以得到一樣的結果。d.getTime() // 1635415168807// 2. 使用 String() 來把日期轉字串。String(d) // 'Thu Oct 28 2021 17:59:28 GMT+0800 (台北標準時間)'// 用 toString() 的結果也是一樣。d.toString() // 'Thu Oct 28 2021 17:59:28 GMT+0800 (台北標準時間)'// 3. 使用 Boolean() 來把日期轉布林值。Boolean(d) // true 隱式轉型 implicit type coercion (JavaScript 幫你轉型)如果把兩個不同資料型別的變數進行運算，JavaScript 會避免發生錯誤而自動把型別進行轉換，確保程式可以繼續執行，但對開發者來說，JavaScript 的貼心很容易造成預期外的結果。 自動轉型成 String 的時機字串跟其他資料型別做+的運算，會把另一個資料型別轉為字串，回傳結果為字串。 💡 會與 String.concat() 的結果一樣 123456789101112131415'2' + 345 // '2345''2' + true // '2true''2' + null // '2null''2' + undefined // '2undefined''2' + NaN // '2NaN''2' + {} // '2[object Object]''2' + [] // '2'&quot;2&quot;.concat(345) // '2345'&quot;2&quot;.concat(true) // '2true'&quot;2&quot;.concat(null) // '2null'&quot;2&quot;.concat(undefined) // '2undefined'&quot;2&quot;.concat(NaN) // '2NaN'&quot;2&quot;.concat({}) // '2[object Object]'&quot;2&quot;.concat([]) // '2' 自動轉型成 Number 的時機使用算術運算子 +、-、*、/、% 來做運算，會把「符號前後」的資料都轉型為數字來做運算，回傳的結果為數字。⚠ 如果+前後的值有一個是字串，則都轉為字串做運算，回傳結果為字串。 12345678910// 轉為數字1 + 123 // 124true + 123 // 124, true 轉為 1null + 123 // 123, null 轉為 0undefined + 123 // NaN, undefined 轉為 NaN// 轉為字串[] + 123 // '123' [] 轉型的時候，觸發toString()方法，優先轉為字串。{} + 123 // '[object Object]123' {} 轉型的時候，觸發toString()方法，優先轉為字串。'2' + 345 // '2345' 其中一個資料是字串，所以 345 轉為 '345' 使用比較運算子 &gt;、&lt;、&gt;=、&lt;=、==、!= 來做運算，會把「符號前後」的資料都轉型為數字來做運算，回傳的結果為布林值。⚠ 如果== 或 != 前後的值都是字串，運算時不會轉成數字。⚠ 如果== 前後的值是 null 或 undefined，運算時不會轉成數字。 123456789101112131415161718123 &gt;= '345' // false '345' 轉為 345123 &gt;= true // true true 轉為 1123 &gt;= null // true null 轉為 0123 &gt;= undefined // false undefined 轉為 NaN123 &gt;= NaN // false NaN 也是數字，沒有轉型直接比較123 &gt;= {} // false {} 先轉為 '[object Object]'，再轉為 NaN123 &gt;= [] // true [] 先轉為 ''，再轉為 0// 字串做「相等比較」不會轉型成數字'123' == '456' // false'123' != '456' // true// null 及 undefined 比較null == 0 // false, null 只會等於 null 或 undefinednull == null // trueundefined == undefined // truenull == undefined // true 自動轉型成 Boolean 的時機使用邏輯運算子(||、&amp;&amp;、!)來做運算，會把「符號前後」的資料都轉型為真值 truthy 或假值 falsy 來做運算，回傳的結果為布林值。 試試看💪 試著解釋下列結果為何? 符號前後轉型為何? 12345678910111213141516171819202122232425262728'2' / 345'2' / true'2' / null'2' / undefined'2' / NaN'2' / {}'2' / []'2' + [2, 3]'2' - [2, 3]'2' * [2, 3]'2' / [2, 3]123 &lt;= '345'123 &lt;= true123 &lt;= null123 &lt;= undefined123 &lt;= NaN123 &lt;= {}123 &lt;= []1 == '1'1 == true1 == null1 == undefined1 == NaN1 == {}1 == [] 參考資料JavaScript type coercion explained JavaScript Type Conversions ECMAScript 2015 Language Specification – ECMA-262 6th Edition Expressions and operators - JavaScript | MDN 你懂 JavaScript 嗎？#8 強制轉型（Coercion） | Summer。桑莫。夏天 JS 中的 {} + {} 與 {} + [] 的結果是什麼？ | Eddy 思考與學習 前端工程研究：關於 JavaScript 中物件的 valueOf 方法 | The Will Will Web","link":"/blog/2021/11/02/js-type-coercion/"},{"title":"JavaScript 變數提升 Variable Hoisting","text":"變數的提升（Hoisting）在其他程式語言裡面，程式碼是逐步執行的，所以「把要做的事情放在宣告之前」，就會出錯。 但在 JavaScript 並不會出錯，因為執行程式碼之前，會先把宣告的函式或變數放到記憶體中，直到程式執行的時候，函式或變數就已經存在了。（感覺像是宣告的東西被提升到要做的事情之前，但實際不是） 要做的事情放在宣告之前，仍然可以繼續執行的現象叫做提升（Hoisting）。 12345sayHello() // Hello!function sayHello(){ console.log(&quot;Hello!&quot;);} var 的提升（Hoisting）在宣告 var 變數之前取用值，會得到 undefined 。 要注意的是，變數只有宣告（宣告指的是var a;）會被提升，因為變數本身還沒有到執行階段，還沒有被賦值（賦值指的是a=0;），所以在宣告之前就取值，我們會得到 undefined 。 用範例的執行過程來說，JavaScript 在程式執行之前，先把 a 放到記憶體中，並給予值 undefined；在執行階段的時候，由於 a 這個變數還沒執行到 a = 0 就被取用了，所以取到的值是 undefined 。 123console.log(a) // undefinedvar a = 0;console.log(a) // 0 let/const 的提升（Hoisting）在宣告 let/const 變數之前取用值，會直接拋出 Error。 雖然宣告的變數在執行之前已經放到記憶體了，但 JavaScript 並不會把 let/const 的值定為undefined，而是暫時不讓你存取。 以結果來看，let/const 確實有 Hoisting 的效果，因為並不是找不到宣告的 let/const 變數，只是暫時不能被存取。這種「從宣告變數到初始化完成之前還不能存取」的限制，叫做暫時死區(TDZ - temporal dead zone)。 123console.log(a) // Cannot access 'a' before initializationlet a = 0;console.log(a) 參考資料我知道你懂 hoisting，可是你了解到多深？ let - JavaScript | MDN var - JavaScript | MDN Day22【ES6 小筆記】變數提升（Hoisting）與暫時死區（TDZ） - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 理解ES6中的暫時死區(TDZ) | Eddy 思考與學習 提升（Hoisting） - 術語表 | MDN","link":"/blog/2021/07/13/js-variable-hoisting/"},{"title":"JavaScript 變數作用域 Variable Scope","text":"變數的作用域（Scope）作用域是指變數的有效範圍。 常聽到的全域變數（global variable）通常是指：全域變數是不在任何function(){}內的變數，換句話說，全域變數是在任何地方都可以用的變數。 跟全域變數相反，function(){}內的變數稱為區域變數（local variable）。 詞法作用域（Lexical Scope）變數的作用域在程式碼寫完的當下就確定了。 用範例的執行過程來說，執行 fnA() 時，會先查找 function 內是否有 a 這個變數，沒有的話就向 function fnA(){}外查找（不是從執行 fnA() 的地方向外查找），所以function fnA(){} 向外找到的a印出來為 0。 所以，即使沒有呼叫fnA()，function fnA(){}裡面的a在寫完的當下就已經確定是 0 了。 123456789101112var a = 0;function fnA(){ console.log(a); // 0}function fnB(){ var a = 1; fnA();}fnB(); 函式作用域（Function Scope）var 變數的作用域在 function(){} 內。 在function(){}內可以向function(){}外查找其它變數（詞法作用域）。但從function(){}外要找function(){}內的變數，則會因為變數的作用域只在function(){}內有效，所以會取不到。 123456789var b = 0;function fn(){ var a = 1; console.log(b); // 0}fn()console.log(a) // a is not defined 區塊作用域（Block Scope）let/const 變數的作用域在 {} 內。 {}、function(){}、if{}、for(){}這種大括號{}的地方，都算是區塊作用域。 var 與 let/const 的差別在於，{}外可以取到 var 的值，{}外不能取到 let/const 的值。 範例的{}可以執行，但只有區塊作用域的用途，無任何功能。 123456789{ var a = 0;}console.log(a) // 0{ let b = 0;}console.log(b) // b is not defined 參考資料JavaScript Scope Scope（作用域） - 术语表 | MDN 區塊 - JavaScript | MDN JavaScript: Introduction to Scope (function scope, block scope) 六角學院 JS 核心筆記 (三)【執行環境與作用域】- 語法作用域 (Lexical Scope)","link":"/blog/2021/07/14/js-variable-scope/"},{"title":"JavaScript 變數 Variables var let const","text":"定義變數是用來儲存值的一個容器。 舉個例子，用 JavaScript 來表示蘋果價格為 25 元 1var applePrice = 25 變數的命名規則 變數必須是唯一的名稱。例如 applePrice 代表的是蘋果價格，它就不會同時是是香蕉價格或鳳梨價格。 可以很簡短。例如 x 或 y；或是很具體的描述。例如 applePrice 開頭第一個字必須是大小寫字母（letter）、底線（_）、錢符號（$），其餘可以包含大小寫字母、數字（0-9）、底線、錢符號。例如 isOpen 或 $price 與 _pchome24H 區分大小寫（case sensitive）。例如 A 和 a 是不同的變數 保留字不能當作變數名稱，例如 null 或 const 變數宣告在 JavaScript 中有三種宣告的方式： var 宣告可改變值的變數，作用域在function(){}內，如果不在任何function(){}內宣告 var 變數，這個變數就會變成全域物件的屬性，或稱全域變數。 let 宣告可改變值的區域變數，或稱區塊變數，作用域在{}內。 const 宣告不可以改變值的常數，因為不可以改變值，所以宣告的時候就必須賦值。 var/let/const 的差異重複宣告var 可以重複宣告，let / const 不可以重複宣告 123456789101112131415// 重複宣告 var 變數，可以正常運行var a = 0var a = 1console.log(a) // 1// 重複宣告 let 變數，會得到錯誤let a = 0let a = 1 // Identifier 'a' has already been declaredconsole.log(a)// function 帶的參數視為已宣告的變數，這時再用let宣告一次，會得到錯誤function fn(b) { let b = 0 // Identifier 'b' has already been declared}fn(1) 先宣告後賦值可以先宣告 var / let 變數之後才賦值。但 const 宣告的時候必須同時賦值，否則會出錯。 1234567891011var a;a = 1;console.log(a) // 1let b;b = 1;console.log(b); // 1const c; // Uncaught SyntaxError: Missing initializer in const declarationc = 1;console.log(c); 重新賦值var / let 可以重新賦值，const 不可以重新賦值 1234567891011// 宣告 let 變數 a = 0let a = 0a = 1 // 重新賦值 a = 1a = 2 // 重新賦值 a = 2console.log(a) // 2// 宣告 const 變數 b = 0const b = 0// 重新賦值 b = 1，會得到錯誤b = 1 // Assignment to constant variable. 作用域var 在 function內，let / const 在{}內 關於變數的作用域，我有另外寫一篇文章：JavaScript 變數作用域 Variable Scope 123456789101112131415// 在 block 內宣告變數，在 block 外取值{ var a = 0 let b = 0}console.log(a) // 0console.log(b) // b is not defined// 在 function 內宣告變數，在 block 外取值function fn() { var c = 0 let d = 0}console.log(c) // c is not definedconsole.log(d) // d is not defined window 物件如果在最外層宣告變數，var 變數可以在 window 這個物件裡找到，let / const 變數不會在 window 裡找到。 123var a1 = 0let a2 = 1console.log(window) 額外的議題討論剛接觸 JavaScript 的時候，最不習慣的地方是變數宣告的地方，因為以前用 C# ，必須在宣告變數的時候也指定好型別，要讓 C# 知道「這是一個正整數的變數」。 1int a = 0; 而 JavaScript 是一個弱型別的程式語言，做變數宣告的時候並不需要先定義變數的型別，只需要讓 JavaScript 知道「這是一個變數」即可。 1var a = 0 JavaScript 還有一個神奇的地方，居然沒有宣告變數也可以用！ 12a = 1console.log(a) // 1 JavaScript 真的可以不用宣告變數？在其它程式語言裡，使用未經過宣告的變數是會出錯的，但是在 JavaScript 卻不是這樣。 以瀏覽器來說，不會出錯的原因在於：這樣的操作是發生在 window 這個物件裡。 所以並不是「使用未經宣告的變數」不會出錯，而是這樣的操作對 JavaScript 來說，是在 window 物件裡添加了一個屬性並使用它。 以為是「使用未宣告的變數」，其實是使用了一個全域物件的屬性（或稱全域變數）。 全域汙染的問題舉個例子，在不知道 init.js 及 main.js 的內容的情況下，要怎麼知道 a 是從哪裡開始產生的？要怎麼知道 a 是在哪裡被改變了？萬一又有其他的地方需要用到 a ，而 a 這個值不正確該怎麼辦？這個 a 已經造成全域汙染的問題了！ 透過這個範例可以知道，在不同的地方用了全域變數，會產生全域汙染的問題。 12345&lt;script src=&quot;init.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;script&gt; console.log(a) // 1&lt;/script&gt; 1234567891011// init.jsfunction fn() { a = 0}fn()// main.jsfunction fnB() { a = 1}fnB() 通常為了避免全域汙染，建議使用宣告變數的方式，把變數的範圍侷限住，以免產生一連串的問題。 12345&lt;script src=&quot;init.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;script&gt; console.log(a) // Uncaught ReferenceError: a is not defined&lt;/script&gt; 1234567891011// init.jsfunction fn() { var a = 0}fn()// main.jsfunction fnB() { var a = 1}fnB() 全域變數有宣告跟沒宣告差別在哪？對 window 物件來說 a 是 window 物件裡的屬性，a 可以用 delete 指令刪除 而 b 雖然也是 window 物件裡的屬性，但它同時是經過宣告的變數，會被當作全域物件裡無法配置（non-configurable）的屬性，所以無法用 delete 來刪除。 123456789a = 0delete window.aconsole.log(window)console.log(a) // a is not definedvar b = 1delete window.bconsole.log(window)console.log(b) // 1 參考資料語法與型別 - JavaScript | MDN JavaScript 那個 let, const, var 到底差在哪？ JavaScript Variables var - JavaScript | MDN","link":"/blog/2021/08/04/js-variables/"},{"title":"問題思考 - 如何保留資料狀態","text":"最近剛結束一個case，是一個滿有挑戰的任務，這裡做成一個小專案來記錄自己的解題思路。情境 1 是已經存在的規則或邏輯，我主要處理的部分為情境 2。在不改變原始的資料的情況下，怎麼讓兩筆資料合併為一筆，並且保留兩筆資料的狀態？ 情境 1小連小吃部有一個菜單系統，客戶從菜單上點菜，必須選擇「料理」跟「料理選項」，才能順利點餐。 菜單規則 選了「料理」後： 如果「料理」有選項可以選，就顯示「料理選項」。 如果「料理」沒有選項可以選，「料理選項」就呈現灰色。 因為必須選擇「料理」跟「料理選項」，沒有料理選項的話，「料理」跟「料理選項」的資料都會是一樣的。 菜單資料12345678const menuData = [ {food: '牛肉湯', price: 100, options: ['牛肉湯']}, {food: '牛肉料理', price: 120, options: ['牛肉飯', '牛丼飯']}, {food: '蛋炒飯', price: 60, options: ['蛋炒飯']}, {food: '培根炒飯', price: 80, options: ['培根炒飯']}, {food: '炒時蔬', price: 100, options: ['炒時蔬']},] CodeDemo 情境 2小連收到客人的建議：牛肉湯就該放在牛肉料理才合理。小連想想也對，於是向前端工程師提出了需求。 需求 牛肉湯要顯示在牛肉料理的料理選項裡面。 選到牛肉湯的時候還是原本的價格。 原本的菜單的資料結構不能動。 思路 原本的資料不動，而是把原本的資料當作基礎，用來做成新的菜單 效果：把牛肉湯放到牛肉料理的選項裡面，並且把牛肉湯從料理移除 在牛肉料理的資料擴充一個 function 效果：選擇牛肉料理選項的時候，用來切換牛肉湯的價格 CodeDemo 心得要讓兩筆資料合併為一個最困難的地方是，我需要保留兩筆資料的狀態，在需要的時候能夠使用。 最後我用閉包來解決這個問題，這樣的好處是外面改變不了原始的資料，又能在需要的時候呼叫閉包來切換資料。","link":"/blog/2021/09/29/my-example-how-to-store-data-state/"},{"title":"帶新人的收穫與經驗分享","text":"帶新人的幾個收穫去年底帶兩個新鮮的前端工程師，看著他們逐漸上手而感到欣慰。 第一次帶新人的我，得到了寶貴的經驗： 比起技術跟產出，讓他們學會跟人協作最優先。 包容犯錯，針對錯誤的行為要導正，只要沒把正式環境弄壞都是學習的機會。 一次只教一件事，人類對於沒接觸過的東西很快就會忘記了，我們很輕鬆就能記得的流程，新人大概只能記得其中一個步驟。 還能加強的部分作業設計因為當時時間趕，沒有從一開始就給予足夠的資訊，我觀察到新人有時候可能會有困惑、需要更多的解釋與指引，所以花了很多時間在講重複的原則跟規範。 假使未來還有機會帶新人的話，我會盡量在設計作業的時候，提供更多完整的資訊，讓新人更容易專注在完成作業。 鼓勵發問後來跟新人比較熟了，才知道一開始新人遇到困難時，會擔心問出太基礎的問題，怕給人一種伸手牌的感覺，而花更多時間卡關。 我鼓勵他放下這樣的想法，進步得會比較快，要厚臉皮一點才學得到東西。 如果可以的話，在新人進團隊的第一天，就能先讓新人知道這一點的話就更好了。 後記","link":"/blog/2023/02/23/mentoring-experience/"},{"title":"nodejs 怎麼處理 Windows 及 Linux 的路徑","text":"最近在逐步把開發環境移到本機上，原本在 Linux 運行好好的程式，到 Windows 上都出錯了 具體情況假設原本在 Linux 上的路徑為 C:/app/index.js 在 Windows 的路徑就會變成 C:\\\\app\\\\index.js google 後找到這篇解釋 Linux 與 Windows 作業系統的路徑斜線(/)、(\\)不同及解法 node 如何兼容 Linux 與 Windows 的路徑？主要會用到 node.js 的 path.sep 這個 api，它會針對不同的平台解析出該平台使用的斜線 在 Linux 的路徑斜線為 /在 Windows 的路徑斜線為 \\ 為了要讓程式正常運行，我們希望把路徑統一為 C:/app/index.js所以要把 Windows 的路徑轉換為 Linux 的路徑格式 1234567// node dependenciesconst path = require('path')// 假設 nodejs 在 windows 取到的路徑為 C:\\\\app\\\\index.jslet windowsPath = 'C:\\\\app\\\\index.js'console.log(windowsPath.split(path.sep).join('/')) // C:/app/index.js 參考資料Path | Node.js v18.9.0 Documentation Nodejs 小知识— Linux 与 Windows 下路径分隔符问题","link":"/blog/2022/09/15/nodejs-path-sep/"},{"title":"在 Windows 用 nvm 切換 Node 版本","text":"安裝nvm在此下載建議安裝到C:\\底下，因為有的Windows使用者名稱是中文的，可能會沒辦法正常運行 cmd指令 查詢可安裝的Node版本 1$ nvm list available 安裝你要的版本號 1$ nvm install &lt;version&gt; 查詢已經安裝的Node有哪些版本 1$ nvm list 使用你要的Node版本號 1$ nvm use &lt;version&gt; enjoy~","link":"/blog/2020/08/28/nvm-windows/"},{"title":"用不同的寫法來實作 Todolist","text":"為什麼大家都在做 TodoList？ 因為 Todolist 包含完整的 CRUD 行為，又功能需求不複雜，很適合當作小專案來練習。 最近六角學院的公開活動 Vue3 夏令營，還有自己練習 JavaScript 的關係，用不同的寫法實作 Todolist 後，總結出上述的心得。 在這裡記錄一下寫法上的差異。 Vue options apiVue2 的寫法 (Vue3 也通) 起手式12345678910111213Vue.createApp({ data() { return { // 資料 } }, methods: { // 方法 }, mounted() { // 生命週期 },}).mount() 不容易迷路因為已經知道甚麼東西會寫在哪裡，在閱讀上比較不會迷路例如：要知道@click=&quot;addTodo&quot;是觸發哪個 method，就去 method object 裡面找 123456789101112131415161718192021222324252627methods: { addTodo() { if (!this.todoText) return // 建立一個todo const newTodo = { text: this.todoText, id: Date.now(), isComplete: false, } // 存到todolist this.todolist.push(newTodo) // 存到localStorage localStorage.setItem(&quot;todolist&quot;, JSON.stringify(this.todolist)); // 清空目前輸入 this.todoText = '' }, editTodo(item) { this.editItem = { ...item } }, cancelEdit() { this.editItem = {} },} Vue composition apiVue3 提出的 composition api 的寫法 跟 Vue2 通用的部分template 的寫法大部分一樣 起手式12345678Vue.createApp({ setup() { // data、method或computed或生命週期都寫在這裡，沒規定你要怎樣的順序寫 return { // 回傳用到的data、method或computed } },}).mount() 不再到處都是this.*了改用ref、reactive的方式來存 data，取值的時候改為.value。method 就像一般 function 的寫法，要用的話直接呼叫。 1234567891011121314151617181920212223242526Vue.createApp({ setup() { // data、method或computed或生命週期都寫在這裡，沒規定你要怎樣的順序寫 const todolist = Vue.ref([]) const todoText = Vue.ref('') // 刪除一個 const deleteTodo = targetId =&gt; { const index = todolist.value.findIndex(item =&gt; item.id === targetId) todolist.value.splice(index, 1) } // 刪除全部 const clearTodoList = () =&gt; { todolist.value = [] } return { // 回傳用到的data、method或computed todolist, todoText, deleteTodo, clearTodoList, } },}).mount() computed 的寫法，依然是以前那個 function return 的味道。 1234567891011const showTodoList = Vue.computed(() =&gt; { return todolist.value.filter(item =&gt; { if (filter.value === '已完成') { return item.isComplete === true } else if (filter.value === '未完成') { return item.isComplete === false } else { return item } })}) 可以讓程式碼的功能做更好的分類不再分成data、method或computed或生命週期的區塊，所以沒有範圍限制了，寫法上更有彈性了。 vanilla js就是原生 JavaScript 的寫法 程式碼很長大多都是操作 DOM 的程式碼。簡單的操作 DOM：1.先選到它、2.再綁定事件，但往往沒這麼簡單，如果功能複雜一點就會又臭又長。 程式碼不容易區分功能區塊處理資料跟處理畫面的功能很容易寫在一起。 很容易踩到作用域跟執行順序的坑執行順序的坑：要自己定義程式的流程，例如初始化的時候要做甚麼事情，要甚麼時候才執行初始化？這都要看程式碼的順序決定呼叫的位置。 作用域的坑：因為我習慣用 arrow function 的寫法，但如果 element.addEventListener 的 callback 需要用 this 時，還是必須改為 function declaration 的寫法 123456789101112131415// 完成 todoconst completeTodo = e =&gt; { const index = todolist.findIndex(item =&gt; item.id === id) // this 會指向 window object todolist[index].isComplete = this.checked textElement.classList.toggle('line-through')}// 完成 todofunction completeTodo(e) { const index = todolist.findIndex(item =&gt; item.id === id) // this 會指向用到這個 function 的 Element object todolist[index].isComplete = this.checked textElement.classList.toggle('line-through')} 最後，有興趣的話可以看一下我的 Todolist 。 我的 TodoList 功能 可以 新增、呈現、編輯、刪除 todo 可以 完成 todo 可以 過濾(全部、已完成、未完成) todo 可以把 todolist 存到 LocalStorage 用 bulma 自創版型 用不同的寫法來實作 TodoList 寫法 Demo link Code link Vue options api demo code Vue composition api demo code Vanilla js demo code","link":"/blog/2021/08/13/project-todolist/"},{"title":"putty 使用 ssh 登入遠端無須密碼","text":"先用putty登入遠端 生成金鑰，一直enter到完成 1$ssh-keygen 讀取金鑰，金鑰的內容會輸出在畫面上，先把它複製起來 1$cat ~/.ssh/id_rsa.pub 編輯authorized_keys，貼上剛剛複製的內容，Ctrl + X 存檔 1$nano ~/.ssh/authorized_key 設定權限 12$chmod 700 .ssh$chmod 600 .ssh/authorized_keys 把.ssh資料夾的id_rsa下載到本地端，用puttyGen讀取成功後，Save private key至C:\\Users\\{username}\\.ssh 開啟putty進行登入設定7-1. 左邊選單Connection-&gt;SSH-&gt;Auth，選擇到剛剛存的Private key7-2. 左邊選單Session，Host Name改為 登入帳號@ip 例如 abc@127.1.2.12 Open，以後都不需要輸入帳號密碼囉！","link":"/blog/2020/09/21/putty%E4%BD%BF%E7%94%A8ssh%E7%99%BB%E5%85%A5%E9%81%A0%E7%AB%AF%E7%84%A1%E9%A0%88%E5%AF%86%E7%A2%BC/"},{"title":"重構的心得與建議","text":"去年針對購物車做了重構，主要是每次開發都覺得很挫折 因為我看程式碼的感覺就像： 早上準備上班的時候，你走到陽台的洗衣機前開水龍頭洗臉刷牙，再到從床底下找到今天要穿的衣服穿上之後，從冰箱拿出鞋子穿好出門。 你不能說這個流程有問題，因為你還是完成了準備上班(It does works.)只是什麼東西在什麼地方、在什麼地方做什麼事情，都不對勁…痛點大概就是這樣。 重構的心得剛好那段時間有想嘗試的技術、也有一些時間可以重構，於是我做了算是滿大的重構 所有功能都不變，資料該在哪就在哪、方法重寫來增加可讀性，順便修正了一些 bug，也算是完成離職同事留下的遺願(?) 現在回想起來其實有點自我滿足，雖然我知道載入速度提升了一點點、也知道開發體驗變好了，痛苦減輕了。 但是，當時沒有其他人維護同樣的程式、也沒有幫公司帶來什麼價值，so… who cares? 選擇有價值的部分去重構萬萬沒想到還真的有人對這段重構的經驗會有興趣！ 最近在前端會議上，新人問到重構的建議，我分享一個想法：做對團隊有價值的重構，雖然可能會需要其他部門的協助，但完成的話可以提升團隊的效率。 給新人的建議：給你方向不如給你信心其實我知道他想問的是技術方面怎麼實作，在會議結束之後，我私下跟他說：「給你方向不如給你信心，想嘗試的事情就盡量去做，很多時候嘗試過才知道怎樣做比較好。」","link":"/blog/2023/02/18/refactor-suggestion/"},{"title":"那些年我想重構卻動不了的專案，AI 只花幾個小時就幫我搞定了","text":"這是一個我多年前在職訓局上課時寫的番茄鐘小專案。檔案裡藏著許多現在看來有些「青澀」、甚至讓人想扶額的程式碼。這幾年來，我心裡一直有個聲音想把它徹底重構，但每次打開專案、評估完那龐大的時間成本後，就又默默地把它埋回 GitHub 的角落。 大約半年前重構的念頭又冒了出來，起因是我常常收到 GitHub 的信，通知我這個專案的依賴太舊了要處理，這讓我覺得很煩。但說實話，半年前的 AI 工具（像是 Claude Code）對我來說比較像是在「輔助開發」，我還是需要掌握很多框架與配置的知識。 那時我評估，即便有 AI 幫忙，我也沒心力把 Vue 2 升級到 Vue 3。即便我具備一些 Vue 3 的知識，但不見得 AI 寫出來的東西不需要我 debug。我預期自己還是得進到程式碼裡去看他寫得如何，改完可能也要花上一整週，所以當時就作罷了。 直到最近，我換了 Codex 的 gpt-5.3 模型來嘗試重構看看，發現感覺完全不一樣。現在的 AI 不只是理解力變好了，連做事的準確度也提升許多。更重要的是， Skills 的設計真的解決了以前 LLM 常亂猜 Best Practice 的問題。 這一次，我幾乎沒碰到程式碼，只測試 AI 改完的東西，花了幾個小時就把整個專案遷移完了。因為這次重構的體驗太好了，想特地記錄下來我怎麼做到「一行程式碼都沒碰，就完成了 Vue2 升級 Vue3 的重構」。 重構第一步：別急著寫 code，先拉齊認知每次開發最怕的就是 AI 沒搞清楚狀況就動手。以前的經驗是，如果直接叫它「幫我把專案改成 Vue 3」，它產出的計畫往往會太發散，甚至會預設一套企業級的複雜架構。 我認為要先讓 AI 徹底了解專案，我們才有足夠的 Context 繼續討論。我跟 Codex 協作的步驟大致如下： **先產出 spec.md**：我先請 Codex 掃一遍整個專案，把目前看到的所有功能、細節先寫成一份規格文件。我們要先把「AI 認為的功能」跟「實際上的功能」對齊。 明確技術棧：告訴它我要遷移到 Vue 3 + Tailwind CSS 4，並要求用輕量的 icon 庫取代原本的圖片以降低打包大小。 安裝對應的 Skills：我在 skills.sh 找了對應的工具，裝了 vue-best-practices、tailwind-design-system 等。安裝好這些 Skill 後，AI 就比我還像個經驗豐富的工程師。 產出遷移計劃：講完需求後請他做遷移計畫。中間他把計畫做得太大、太細節了（有很多多人協作的內容），我補了一句：「這只是我個人的小專案，不需要考慮協作。」他立即把計畫改成簡易版，甚至還自動幫我加了 Playwright 做 E2E 測試來當驗收標準。 等到計畫確認沒問題後，我就請他按照計畫開始重構，做完再叫我。 整個過程我就只是在旁邊看 Codex 表演，做完後試了一下，所有功能都完整遷移成功了。（如果你好奇這中間具體改了哪些程式碼，可以參考這份實測的 Pull Request） 讓 AI 幫我重新切版專案遷移成功後，我看著這份五、六年前的 UI，覺得越看越醜。但我手上沒有設計稿，也不想自己慢慢調整 CSS。 於是我又去裝了 frontend-design 的 Skill，請它評估現有介面可以改進的地方，並直接調整樣式。結果非常理想，在沒有設計稿的情況下，我不需自己發想切版，它就自動優化了整體的視覺平衡與質感。 一行程式碼都沒碰，那前端工程師的價值在哪？這次做完最讓我有興奮的是，我真的從頭到尾一行程式碼都沒碰，就把這份五六年前的舊專案翻新了。 我體驗到的是，現在我不一定要有 Vue 3 的開發經驗，只要我能把 Context 給清楚，並且知道怎麼引導 AI 去思考、安裝正確的 Skills 去輔助他。即便這是一個我好幾年沒碰的舊專案，一樣能在幾個小時內重構完。 這讓我開始思考，以前工程師的價值在於 程式設計（Coding）的能力 ，但經歷這次重構，我認為現在更重要的價值反而轉向了： 你對框架的了解：知道什麼技術適合專案，才能選對技術棧。 技術選型與 Skills 的組合：決定要遷移到哪裡、使用哪些工具與 Skills。 與 AI 的溝通能力（Context 管理）：如何把專案背景、開發限制精確地傳達給 AI。","link":"/blog/2026/02/11/refactor-with-ai-agents/"},{"title":"學習新技能的三個訣竅","text":"去年在工作上接觸了 cypress, docker, webpack, vue composition api 等前端技術，並且還有成功應用的經驗，我認為有三個訣竅幫助我有效的上手： 1. 泡腦袋例如我只是想知道 setup() 語法怎麼寫，我就 google 搜尋「vue composition setup」並且在 chrome 分頁開了 20 幾頁類似的文章來讀，官方寫的、別人寫的、中文資源、英文資源都看。 2. 不斷試錯看完相關資源之後，把自己認為對的答案輸入並測試，像做實驗一樣，持續邊做邊查資料，直到搞懂自己為什麼錯了。 3. 寫下來把自己實驗的過程、想法、感受、結論通通寫下來，並且不斷地去修正這份紀錄，不要用腦袋來記錄。 寫下來可以幫助清空腦袋，把腦力拿去思考解法，還有另外一個好處是，晚上睡覺就不會一直想。 怎麼做？這裡分享具體要怎麼做？ 我實際寫下來的筆記 這個筆記主要是紀錄我想要用 vue composition api 重構露天購物車前端程式的筆記。 最後我得到了應用的經驗、還有以免下次會忘記的手冊。","link":"/blog/2023/02/02/three-tips-for-learning-a-new-skill/"},{"title":"公司需要的是工程師，還是只是把工作做完的人？","text":"最近與主管進行面談時，聊到了團隊成員的技術成長與 AI 協作的現況。這引發了我的一連串思考：當 AI 已經能代勞大部分的實作時，開發者的核心價值究竟剩什麼？ 針對基礎尚不穩固的開發者，AI 確實提供了一個「把事情做完」的機會。但這也帶出了一個殘酷的現實問題：公司需要的是一個真正的「工程師」，還是只要一個「能把工作完成的人」？ 同樣的工作量，有經驗的開發者或許一兩小時就能產出，但仰賴 AI 卻不求甚解的人可能需要一週。這中間的差距，往往不在於工具的使用，而在於個人的積極度。 我的觀察： 積極的人輕輕一推就能衝得很遠；不積極的人，再大的推力也只能前進一點點。若不具備相應的技術判斷力，在市場競爭力上，甚至可能不如一個成本更低但效率更高的人選。 在「程式碼能跑」之外，你有沒有自己的內心小劇場？當每個人都在用 AI 時，「工程師」與「完成事情的人」之間的差距反而更加明顯。AI 產出程式碼的成本已經變得極其廉價，我們不需要與之競爭熟練度，而是要競爭「判斷力」。 如果你只是想「把事情做完」，你可能會覺得： 「程式碼貼上去，功能確實運作了，畫面上看起來沒問題，任務完成。」 但如果你是一個對品質有堅持的工程師，你的「內心小劇場」應該是： 「雖然程式碼跑起來了，但這真的是最優解嗎？它會不會對系統的其他部分造成連動影響？我現在解決了一個問題，是不是反而埋下了另一個效能隱患？我有沒有更優雅的現成工具可以用，而不是讓 AI 寫出一段冗餘的邏輯？」 不要把判斷對錯的責任丟給別人我聽過最誇張的案例是：對 AI 給的程式碼照單全收，即便 Review 時收到大量反饋，依然固執地按自己的方式做事，因為他只求「有產出」，而不求「產出對的成果」。 在我們依賴 AI 提升效率的同時，最不能缺少的就是 Ownership（責任感）。這是區分一個開發者是否能「獨立負責」的關鍵。這種責任感具現在最基本的開發態度上： 當你提交一段程式碼時，你是否能清楚說明自己為什麼這樣寫？ 你是否真的知道自己在解決什麼問題？ 如果在開發過程中遇到無法解決的困難，是否能主動且積極地尋求幫助，而不是塞入一段自己也看不懂的 code，然後把判斷對錯的責任丟給主管或 Reviewer。 如果只是把 AI 給的答案貼上去，卻無法解釋其中的邏輯，這不叫完成工作，這叫放棄思考。一個無法獨當一面、無法被信任專業程度的開發者，長期看來，只會成為打工仔，而不是工程師。 這個時代的工程師應具備的自覺雖然 AI 讓產出變得快速，Coding 的純熟度不再是唯一的競爭標準，但要讓 AI 產出的結果「受控」，開發者反而需要更紮實的軟體工程底子。不論資歷深淺，我認為在 AI 時代有幾點是我們都應具備的自覺： 釐清問題永遠優先於寫 Code：接到任務後，重點不是趕快把 Code 生出來，而是理解這個需求背後要解決什麼問題。只有釐清了問題的本質，你才能建構出正確的邏輯，而不是被 AI 的建議牽著走。 把 AI 的產出當成「學習教材」，而非「最終解答」：AI 時代的開發者已經不需要再從 0 到 1 寫程式了，但我們要理解 AI 給的 0.8 的產出是在做些什麼，不要只是 Accept，而是去拆解它為什麼這樣設計。你得先有能力看懂那段你寫不出來的程式碼，那份經驗才會真正累積在你身上。 用正確的態度累積實戰經驗：為你的產出負責。這代表每一行程式碼你都理解其用意，並且在出問題時，有能力去面對、討論並修正。這才是真正能累積在自己身上的專業價值。","link":"/blog/2026/01/30/value-of-engineer-with-ai/"},{"title":"設定 git 使用者及信箱","text":"在vscode裡面如果沒有設定使用者，就無法正常的使用git功能。或是有時候有切換使用者的需求，就用指令來解決吧!! 記得打開終端機(termial)，並且cd到你要設定的目錄下 查看git使用者及信箱terminal12$ git config user.name$ git config user.email 修改git使用者及信箱terminal12$ git config user.name &quot;username&quot;$ git config user.email &quot;user@email.com&quot;","link":"/blog/2020/12/15/vscode-git-config/"},{"title":"Vue元件溝通-觸發父元件的事件(parent.$emit)","text":"經由子元件來觸發父件的事件把事件綁在父元件裡this.$on('say-hi')子元件呼叫這個事件的時候要寫成this.$parent.$emit('say-hi') 123456789101112131415161718192021222324252627282930/* 子元件 */&lt;div id=&quot;child&quot;&gt; &lt;span&gt;子元件&lt;/span&gt; &lt;button @click=&quot;clickButton&quot;&gt;Click!&lt;/button&gt;&lt;/div&gt;...methods: { clickButton(){ this.$parent.$emit('say-hi') }}/* 父元件 */&lt;div id=&quot;parent&quot;&gt; &lt;span&gt;父元件&lt;/span&gt; &lt;child&gt;&lt;/child&gt;&lt;/div&gt;...mounted(){ this.$on('say-hi', this.sayHi)},methods: { sayHi(){ alert('Hi~~') }}... 寫法上的差別我寫了一個codepen，可以觀察觸發子元件的事件與觸發父元件的事件這兩個差別 參考資料https://stackoverflow.com/questions/45144483/difference-between-this-parent-emit-and-this-emit","link":"/blog/2021/02/18/vue-parent-emit/"},{"title":"vuex actions與mutations的差異","text":"一開始看不懂vuex為何要分mutation跟action兩個寫法，後來查閱了一些資料、加上問公司的前輩，雖然明白了，但還沒辦法體會。 目前先記錄下來，不保證以下內容是正確的觀念。 mutation是同步處理，action是異步處理vuex有個很重要的原則，必須由mutation來改變state，所以如果讓mutation可以異步處理的話，就很難追蹤正確的值。點這裡查看官方怎麼說 假設一個簡單的情境：A商品加入購物車後，state被改變了。 action確實類似mutation，但是其實是設計來「可以」做異步處理。 用mutation的話，相當於直接更動state的值；如果在一個.vue做的話，我可能會直接做完異步處理，成功的話再mutation。 但今天如果很多地方都可以加入購物車，我就必須封裝「加入購物車」的方法，然後在各處引用… 那不如一開始就寫在actions裡面，每次都叫這個action去處理就好了。 這裡可以看官方舉的加入購物車的例子 看完官方的文件後，真正的結論是mutation「必須」是同步處理，action「可以」是異步處理 其他人的理解mutation在乎的是state，action在乎的是要執行的事情https://stackoverflow.com/questions/39299042/vuex-action-vs-mutations","link":"/blog/2020/12/11/vuex-actions-and-mutations/"},{"title":"webpack 打包速度救星 esbuild-loader","text":"最近在優化公司專案用的 webpack，查資料查到這篇文章， 一看到 webpack 可以使用 esbuild 來提升速度，很興奮地跳下去實驗了 關於我遇到的問題今年微軟終於不再支援 IE，公司方面也跟進不支援 IE 瀏覽器。 以目前公司的專案為例： 原本開發模式的編譯速度為 4 分多鐘，生產模式因為還有程式碼壓縮及其他設定的關係，則需要花更多的時間才能編譯完。 於是我嘗試調整 webpack 設定，主要都在針對 babel-loader 的設定在做測試，但即使不再相容 IE 了，開發模式的編譯速度也只少了 1 分鐘。 總覺得只進步 1 分鐘的成果仍然不是很好… 另外也一邊研究別的打包工具，如果可以調整專案架構的話，或許有機會使用 vite，但那又是更大的工… 直到我遇到了 esbuild-loader 實測數據以下是透過調整 webpack.config.js 得出來的數據。 差異項目 babel-loader esbuild-loader 成果 花費時間 4 mins, 13 secs 1 mins, 26 secs 省下 2 mins, 47 secs 檔案大小 100% 67% 瘦身 33 % 快速開始取代 babel-loader 來提升打包速度的救星：esbuild-loader 使用 esbuild-loader 取代 babel-loader 的條件：支援 ES6 1. 安裝1npm i -D esbuild-loader 2. 把 babel-loader 設定改為 esbuild-loader 設定12345678910111213141516171819202122// webpack.config.js module.exports = { module: { rules: [- {- test: /\\.js$/,- use: 'babel-loader',- },+ {+ test: /\\.js$/,+ loader: 'esbuild-loader',+ options: {+ loader: 'jsx', // Remove this if you're not using JSX+ target: 'es2015' // Syntax to compile to (see options below for possible values)+ }+ }, ... ], }, } 3. 開始體驗 🎉使用平常啟動 webpack 的指令，例如 npm run dev，來體驗更快的打包速度吧！ 問題集esbuild-loader 為什麼快？esbuild-loader 調用 esbuild 的 transform api 來轉譯。 大多數前端工具是用 js 實作的，運作的時候需要先解析後才能讓機器執行。而 esbuild 是用 go 寫的，可以直接在編譯階段就讓機器執行了，所以比起 js，少了一段需要解析程式的工作。另外 go 擁有多線程的優勢，盡可能調用 cpu 的性能，而不像 js 是單線程的語言。 詳細可參考資料 Esbuild 为什么那么快 若使用到 ES2015 以上的 api，程式會異常嗎？以?.這個語法為例，實測轉譯如下，程式可以正常執行 12345// 原始碼let foodApple = desk.food?.apple// 編譯後let foodApple = (_a = desk.food) == null ? void 0 : _a.apple 結論esbuild-loader 可以取代 babel-loader 進行 js 轉譯，打包速度提升一倍，並且縮小檔案大小。缺點是只支援 ES6 以上的語法。 實際使用後打包速度雖然沒有快到飛起來，但也是我目前用過超快的 webpack 打包速度了。 這樣看下來 webpack 又可以再戰三年、五年了吧。","link":"/blog/2022/10/26/webpack-esbuild-loader/"},{"title":"Git 原理與版本控制知識","text":"看了高見龍的影片《你知道Git是怎麼一回事嗎》，學習Git的原理，趁著記憶猶新來寫一下筆記。 我的收穫這部影片釐清了我的Git觀念，也解釋了我一直搞不清楚為何效能比SVN好。推薦給平常有再使用Git、但實際上不知道Git是怎麼運作的人看這部影片。 版本控制先定義什麼是版本? 目錄或檔案的變化，每一次的變化就叫做一個版本。 Git跟其他版本控制軟體的差異 Git只在乎檔案內容，不在乎目錄或檔案名稱 有的版本控制是在比對檔案來記錄差異；而對Git來說，只要沒有變化的檔案就會是先前的版本。 Git怎麼知道檔案有變化?先講SHA1演算法 Git使用SHA1演算法來確認檔案內容的變化。 SHA1會輸出40個16進位字元組成的字串來輸出Git物件檔名 輸入一樣的內容，就會有一樣的輸出值。輸入不一樣的內容，就會有不一樣的輸出值。 有可能會發生碰撞(輸入不一樣的內容卻輸出一樣的值)，但機率非常非常小 Git裡面的blob計算公式=&gt;'blob'+1個空白+內容長度+Null結束字符+輸入內容 在Git裡面每個物件都有自己的SHA1 再講Git物件有4種type blob放跟檔案有關的資訊，檔案內容有變化blob就會有變化。 tree放跟目錄有關的資訊，blob有變化，tree也會有變化。 commit放跟提交有關的資訊，tree有變化，commit也會有變化。 tag放跟tag有關的資訊，commit有變化，tag也會有變化。 這裡的”變化”是指SHA1值被改變了 運作原理當被Git追蹤的檔案內容發生變化，blob的SHA1值就會不一樣，tree跟commit也會跟著不一樣。 因為Git只在乎檔案內容，不在乎目錄或檔案名稱 關於分支 其實分支不是copy一份檔案來改，而是某一個branch指向某一個commit物件 HEAD是指向某一個branch，通常可以當作當前的branch 切分支的時候，是把repo的東西搬一份到工作目錄 checkout跟merge就是分支跟HEAD移來移去而已 rebase v.s. merge rebase是把檔案複製一份放到要rebase的分支，然後放棄原先的線，與rebase的分支成為同一條線 merge是從兩條線合併為一條新的線 master可以刪掉嗎? 可以，但是你不能branch在master的時候這麼做，必須先切到別的分支 把還沒合併的分支刪掉 rev-parse 分支 算出分支的SHA1值 git branch -D 分支 強制把還沒合併的分支刪掉，-d會有保護 git branch new_分支 SHA1值 開一個新的分支，並指定SHA1 東西就復活在這個新的分支了 把hard reset掉的東西救回來 git reset HEAD~2 --herd 強制倒退兩個commit，並且刪除commit git reflog 顯示之前的操作，找到被刪除的commit節點 git reset 被刪除的commit節點 --herd 強制回到被刪除的commit 標籤(tag) 不會隨著commit前進，但branch會 留下來的是tag，跟你走的是branch git資源回收(garbage collection) 當物件數太多的時候，git會自動做gc，但也有手動觸發的方式 git count-objects 現在有幾個東西 git gc 打包垃圾，會收在objects/pack裡面 tree .git 可以看到.git資料夾的目錄","link":"/blog/2021/02/24/what-git-is/"},{"title":"如何做一個Line機器人","text":"前置作業 Heroku 註冊帳號 Node.js 到官網下載14.0.0，再直接安裝 Line Developers 用Line帳號登入Line Developers 建立一個provider 建立一個MessageAPI 用Line加好友 ngrok 用github登入 下載ngrok ngrok是用來轉發http內容跟line機器人溝通，我們自己在開發的時候用來測試的 專案設定Node.js安裝套件 打開VSCode，為這個機器人建立一個專案目錄 打開VSCode終端機(推薦使用Cmd)： 移動到你的專案目錄，如圖 npm init 初始化你的專案目錄會產生package.json 如果你的package.json已有記錄你裝的套件，你可以用npm install指令來安裝所有套件 編輯package.json，加入兩個指令 12345678{... &quot;scripts&quot;: { &quot;start&quot;: &quot;node index.js&quot;, &quot;dev&quot;: &quot;nodemon index.js&quot; },...} 安裝nodemon套件 npm install -g nodemon -g 全域安裝modemon 存檔的時候就會幫忙重新啟動node.js 安裝環境設定檔套件npm install dotenv 安裝line機器人套件npm install linebot 安裝API套件npm install request、npm install request-promise 安裝node.js的程式碼風格格式化的套件npm install -g eslint F1=&gt;Create eslint…終端機要在你的專案目錄 終端機會自動出現eslint初始化，照圖片回答即可 有上傳Git的話，記得把node_modules/加入.gitignore清單 ENV環境設定檔 VSCode安裝DotEnv套件 專案目錄下建立.env檔案，內容寫入如下(變數裡面的自己去LineDevelop找)1234CHANNEL_ID=&quot;&quot;CHANNEL_SECRET=&quot;&quot;CHANNEL_ACCESS_TOKEN=&quot;&quot;PORT=3000 有上傳Git的話，記得把.env加入.gitignore清單 ESlint設定 VSCode 鍵盤F1=&gt;搜尋setting=&gt;喜好設定:開啟設定(JSON) 在setting.json內加入這一行 12345{...&quot;editor.codeActionsOnSave&quot;: {&quot;source.fixAll.eslint&quot;: true}...} 機器人設定 在專案目錄下建立index.js輸入這些東西 LineDevelopers裡面去把自動回應關閉 設定ngrok ngrok.exe放到專案目錄 在終端機裡面輸入Ngrok提供的指令ngrok authtoken ...(記得./要拿掉) 在終端機裡面輸入ngrok http 3000啟用ngrok http連線 開另一個新的終端機輸入npm run dev啟用node.js dev是npm nodemon index.js指令 把ngrok給的https路徑貼到MessageAPI的URL，如果成功的話打開Use Webhook(可能要等一下才能驗證) 撈API寫成下面這樣，當使用者跟機器人說話，機器人會回應kktix第一個活動的標題。需要import request-promise 套件 相關連結npm linebotnpm request-promise heroku設定這是一個雲端伺服器，用來存放機器人，Heroku自己有https，所以不用擔心ngrok換網址了 登入後，建立一個App 在這個app的後台的Deploy頁面，選用github連動，選擇到自己的儲存庫 到setting頁面設定Config Vars 部屬你的機器人，點Deploy branch，成功之後點view按鈕，把給的網址複製起來 貼到LineDevelopers的MessageAPI的Webhook URL 相關套件解析HTML - cheerio如果你想撈的資料是沒有API的話，可以用cheerio去解析HTML搭配request-promise可以拿到的HTML資料，配合利用JQ語法解析cheerio 解析XML - XML2js排程 node-schedule可以指定機器人每天幾點去做事情(撈資料之類的)","link":"/blog/2020/04/29/%E5%A6%82%E4%BD%95%E5%81%9A%E4%B8%80%E5%80%8BLine%E6%A9%9F%E5%99%A8%E4%BA%BA/"},{"title":"敏捷（agile）到底是什麼？","text":"傳統的開發流程傳統的開發流程都是一層一層(又稱瀑布式開發)，每層顧好自己負責的事情就好。 瀑布式開發最常發生的問題是：好不容易花了很多時間層層作完，結果發現問題一大堆。 舉例來說，工程師拿到規劃文件後負責執行，有要 argue 的事情也都會是在技術的層面，這個需求要達到什麼目標不重要，工程師的目標是把東西實作出來。 敏捷開發網路上查到的敏捷，都提到可以改善工作效率，但都沒講到重點； 其實最核心的問題是：大家有沒有進入狀況？大家的目標是否一致？ 當每個人都知道為什麼產生了某個問題、而這個需求是為了達到什麼目標，針對這個目標，不同位置的人需要做什麼努力？ 不再是只有一兩個大腦來決定事情的發展，而是共同去承擔結果，把大家腦袋用的地方切分清楚、才能提升組織的效率。","link":"/blog/2021/12/01/what-agile-is/"},{"title":"實作JWT機制的登入驗證","text":"運作流程 Client登入請求 Server接到請求，確定登入後簽發Token給Client Client收到Response，並記下Token Client=&gt;需要驗證的操作都要帶Token給Server Server=&gt;需要驗證的操作都要解析Token確認是本人 Server環境及套件Node.js + Expressjsonwebtoken 簽發Token寫法1const token = jwt.sign(playload, secret, options) playload:你要塞的資料，通常會塞用戶資訊之類的secret:密鑰，自訂一的字串，解析的時候也會用到options:可以加一些設定在這個簽章裡 解析Token寫法1const verify = jwt.verify(token, secret) token:簽發出去的tokensecret:密鑰，自定義的字串 jwt.verify()必須在try catch裡才可以正常執行 Client登入寫法123456789this.axios.post(API + 'login' ,{ account, password}).then(response =&gt; { // 登入請求成功 // 從response取出token存起來，之後需要驗證的請求都可以拿來用}).catch(error=&gt;{ // 登入請求失敗的話要做的事情}) 使用Token的情境當Client向Server請求訂單資料，Client需在請求的Header中攜帶Token，讓Server解析用戶資料 寫法12345678this.axios.get(API + '/order' ,{ headers: { Authorization: 'Bearer '+ token } }).then(response =&gt; { // 請求成功的話要做的事情}).catch(error=&gt;{ // 請求失敗的話要做的事情}) 習慣上會把Token放在header的Authorization裡面","link":"/blog/2020/08/18/%E5%AF%A6%E4%BD%9CJWT%E6%A9%9F%E5%88%B6%E7%9A%84%E7%99%BB%E5%85%A5%E9%A9%97%E8%AD%89/"},{"title":"用Hexo建部落格踩到的坑","text":"在職訓的時候寫了markdown的筆記想說要找地方放出來，正好在待業中的階段可以練一下自架markdown的blog 查了些資料後，決定選擇Hexo，小聲地說是因為作者是台灣人，當然要支持一下 樣式的選擇架設的過程中看了很多樣式，本來決定要用NexT，但架設出來的樣式不是我最順眼的 後來又找到Minos，可是我想要可以顯示頭像等一些資訊的側邊攔 沒想到與Minos同一個作者有另一個主題叫做icarus，並且有完整的中文建置教學 所以最後就決定用icarus 本站的Logo本站的中心思想：喜歡coding，喜歡解決問題 所以用上了我的英文名字Bolas，搭配寫程式會用到的分號; 用AI畫了這樣的圖 再來說踩到的坑 繼續閱讀/閱讀更多/more在還不熟悉Hexo的架構下，我的文章內容是整篇都顯示出來，查了很多關鍵字，才找到可以用 &lt;!-- more --&gt;來決定文章預覽的範圍。 佈署好不容易把部落格的內容調整好了，在hexo s下可以正常顯示，在hexo g打包出來的index.html卻不正常(css不見或是整個畫面沒東西).. 為了發布出去，我除錯用了快一整天的時間。 先是懷疑套件有問題，解除安裝跟重新安裝了好多次=&gt; 沒用 懷疑icarus使用的套件會讓打包有問題，重新架了最原始的hexo=&gt; 一樣壞掉 查到資料，好像是node版本的問題，只好去裝nvm，把node從原本的14.9.0降到12.18.3=&gt; 本地打包出來的東西一樣有問題，很神奇的是上github就沒事了 最後總結一下也不知道有沒有人跟我一樣，反正我就記錄一下 環境設定 Node: 12.18.3 hexo: 5.1.1 hexo-cli: 4.2.0 佈署方式 利用Hexo d來發佈到Github 怎麼設定看這篇文章","link":"/blog/2020/08/28/%E6%9E%B6%E8%A8%ADHexo%E9%83%A8%E8%90%BD%E6%A0%BC/"},{"title":"為什麼我不繼續做聖騎士PM","text":"最近面試一直在講一個藏在我心裡好久好久的事，花了很長的時間，還有很大的精力，我才有足夠的勇氣去面對。 高二的時候我代表學校參加屏東區的資訊科比賽，然後我就呆坐在電腦前一題都解不出，直到比賽結束。 高三的時候又再一次代表學校出賽，我很認真的準備，然後又再一次呆坐在電腦前… 這兩次寫程式的失敗給我非常非常非常巨大的打擊，即使…我大學的時候念的是本科系…選修也都修程式語言的課…我出了社會到遊戲業也自己寫工具使用…也涉略了多多少少遊戲開發的程式技術…但我仍不敢把它放到我的職涯選擇中。 我在前一份工作離職後休息了半年，直到我真的逼不得已要開始找工作了，才去考慮轉職的可能。我報名了職訓，做了大大小小的作業，再靠自己的力量完成專題…我才真的解開這個影響我很久很久的結。 我終於能對當時十六、七歲的自己說：沒關係，你以後還是可以做到的。","link":"/blog/2020/08/19/%E7%82%BA%E4%BB%80%E9%BA%BC%E6%88%91%E4%B8%8D%E7%B9%BC%E7%BA%8C%E5%81%9A%E8%81%96%E9%A8%8E%E5%A3%ABPM/"}],"tags":[{"name":"職涯","slug":"職涯","link":"/blog/tags/%E8%81%B7%E6%B6%AF/"},{"name":"HTML","slug":"HTML","link":"/blog/tags/HTML/"},{"name":"vue","slug":"vue","link":"/blog/tags/vue/"},{"name":"career","slug":"career","link":"/blog/tags/career/"},{"name":"Claude Code","slug":"Claude-Code","link":"/blog/tags/Claude-Code/"},{"name":"Claude","slug":"Claude","link":"/blog/tags/Claude/"},{"name":"AI Coding","slug":"AI-Coding","link":"/blog/tags/AI-Coding/"},{"name":"AI 開發工具","slug":"AI-開發工具","link":"/blog/tags/AI-%E9%96%8B%E7%99%BC%E5%B7%A5%E5%85%B7/"},{"name":"開發心得","slug":"開發心得","link":"/blog/tags/%E9%96%8B%E7%99%BC%E5%BF%83%E5%BE%97/"},{"name":"javascript","slug":"javascript","link":"/blog/tags/javascript/"},{"name":"ios","slug":"ios","link":"/blog/tags/ios/"},{"name":"clipboard","slug":"clipboard","link":"/blog/tags/clipboard/"},{"name":"css","slug":"css","link":"/blog/tags/css/"},{"name":"切版","slug":"切版","link":"/blog/tags/%E5%88%87%E7%89%88/"},{"name":"testing","slug":"testing","link":"/blog/tags/testing/"},{"name":"cypress","slug":"cypress","link":"/blog/tags/cypress/"},{"name":"scrum","slug":"scrum","link":"/blog/tags/scrum/"},{"name":"git","slug":"git","link":"/blog/tags/git/"},{"name":"example","slug":"example","link":"/blog/tags/example/"},{"name":"thinking","slug":"thinking","link":"/blog/tags/thinking/"},{"name":"nodejs","slug":"nodejs","link":"/blog/tags/nodejs/"},{"name":"project","slug":"project","link":"/blog/tags/project/"},{"name":"todolist","slug":"todolist","link":"/blog/tags/todolist/"},{"name":"putty","slug":"putty","link":"/blog/tags/putty/"},{"name":"ssh","slug":"ssh","link":"/blog/tags/ssh/"},{"name":"AI協作","slug":"AI協作","link":"/blog/tags/AI%E5%8D%94%E4%BD%9C/"},{"name":"AI-Agents","slug":"AI-Agents","link":"/blog/tags/AI-Agents/"},{"name":"重構","slug":"重構","link":"/blog/tags/%E9%87%8D%E6%A7%8B/"},{"name":"Codex","slug":"Codex","link":"/blog/tags/Codex/"},{"name":"Vue","slug":"Vue","link":"/blog/tags/Vue/"},{"name":"工程師思維","slug":"工程師思維","link":"/blog/tags/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E6%80%9D%E7%B6%AD/"},{"name":"Ownership","slug":"Ownership","link":"/blog/tags/Ownership/"},{"name":"軟體開發","slug":"軟體開發","link":"/blog/tags/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"},{"name":"職涯成長","slug":"職涯成長","link":"/blog/tags/%E8%81%B7%E6%B6%AF%E6%88%90%E9%95%B7/"},{"name":"vuex","slug":"vuex","link":"/blog/tags/vuex/"},{"name":"webpack","slug":"webpack","link":"/blog/tags/webpack/"},{"name":"linebot","slug":"linebot","link":"/blog/tags/linebot/"},{"name":"development","slug":"development","link":"/blog/tags/development/"},{"name":"token","slug":"token","link":"/blog/tags/token/"},{"name":"jwt","slug":"jwt","link":"/blog/tags/jwt/"},{"name":"Express","slug":"Express","link":"/blog/tags/Express/"},{"name":"Hexo","slug":"Hexo","link":"/blog/tags/Hexo/"}],"categories":[{"name":"心得分享","slug":"心得分享","link":"/blog/categories/%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB/"},{"name":"筆記","slug":"筆記","link":"/blog/categories/%E7%AD%86%E8%A8%98/"},{"name":"claude code","slug":"claude-code","link":"/blog/categories/claude-code/"},{"name":"前端技術","slug":"前端技術","link":"/blog/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E8%A1%93/"},{"name":"css","slug":"筆記/css","link":"/blog/categories/%E7%AD%86%E8%A8%98/css/"},{"name":"測試","slug":"測試","link":"/blog/categories/%E6%B8%AC%E8%A9%A6/"},{"name":"軟體開發","slug":"軟體開發","link":"/blog/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"},{"name":"技術心得","slug":"技術心得","link":"/blog/categories/%E6%8A%80%E8%A1%93%E5%BF%83%E5%BE%97/"},{"name":"職涯成長","slug":"職涯成長","link":"/blog/categories/%E8%81%B7%E6%B6%AF%E6%88%90%E9%95%B7/"}],"pages":[{"title":"about","text":"關於我嗨，我是連小艾，一名前端工程師。熟悉的技能為 Scss/Less, Vue, Webpack, Gulp, Git, Linux command line (使用過 docker, cypress)。 我喜歡團隊協作的環境，視團隊為優先，當我協助提升團隊工作效率、或是引導團隊解決難題的時候，我會感到很有成就感。若想要了解更多我的經歷，可以參考我的Linkedin 關於部落格這裡記錄了我的技術學習筆記、踩過的坑，以及軟體開發心得筆記。 聯絡方式 Linkedin Email","link":"/blog/about/index.html"},{"title":"categories","text":"","link":"/blog/categories/index.html"},{"title":"tags","text":"","link":"/blog/tags/index.html"}]}